=======
title: Msc Thesis: The long-term impact of reef design on herbivorous fish biomass and mean size
author: Jorn de Gelder
date: 17/12/2025
---

# if on MSI laptop (Jorn)
setwd("C:/Users/Jorn de Gelder/Documents/Thesis R")

# Setup
```{r setup}
rm(list=ls()) # Clear workspace
knitr::opts_knit$set(root.dir = '/tmp') #Set directory at current directory for all subsequent chunks
options(scipen = 99) # Have all numbers in non-scientific notation

library(readxl) # Join data frames (vlookup)
library(cowplot) # Combine plots
library(patchwork)
library(data.table)
library(ggthemes) # pretty plots
library(flextable) # Layout word table
library(tidyverse) # Beta regression
library(vegan) # Export Excel
library(gridExtra)
library(emmeans) # Select text from string
library(lme4)
library(lmerTest) # GLS
library(officer) # Move table into word
library(gridGraphics) # Combine base and ggplots
library(tidyxl) # Read in coloured cells Excel
library(openxlsx)
library(car) # glm model validation
library(viridis) # Convert data from wide to long
library(writexl) # Export Excel
library(janitor) # Excel functions
library(arrow) # Write & read Parquet
library(ggpubr) # for checking normality
library(ggeffects) # for visualization
library(glmmTMB) #negative binomial
library(DHARMa) #for checking NB & CMP GLMM
library(robustlmm)
library(multcomp) # for CLD
library(multcompView) # for CLD
library(purrr) # for centroid calc
```

# Load RAW data (Only need to run after new raw data input: Takes about 30 mins)
```{r data load, warning= FALSE}

# ---- DATA 2017-2022 ----
## Load
### 2017-2018
fishRAW.2018 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2017-2018.xlsm", sheet = 3, skip = 6))
fish.2018 <- fishRAW.2018[!is.na(fishRAW.2018$Species),] # Remove irrelevant row
fish.2018 <- dplyr::select(fish.2018, -c(1, 3:11)) # Remove irrelevant columns
fish.2018$Species <- sub("\\.", "", fish.2018$Species) # Remove points from species names

### 2019
fishRAW.2019 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2019.xlsm", sheet = 3, skip = 6))
fish.2019 <- fishRAW.2019[!is.na(fishRAW.2019$Species),] # Remove irrelevant row
fish.2019 <- dplyr::select(fish.2019, -c(1, 3:11)) # Remove irrelevant columns
fish.2019$Species <- sub("\\.", "", fish.2019$Species) # Remove points from species names

### 2020
fishRAW.2020 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2020.xlsm", sheet = 3, skip = 6))
fish.2020 <- fishRAW.2020[!is.na(fishRAW.2020$Species),] # Remove irrelevant row
fish.2020 <- dplyr::select(fish.2020, -c(1, 3:11)) # Remove irrelevant columns
fish.2020$Species <- sub("\\.", "", fish.2020$Species) # Remove points from species names

### 2021-2022
fishRAW.2021 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2021-2022.xlsm", sheet = 3, skip = 6))
fish.2021 <- fishRAW.2021[!is.na(fishRAW.2021$Species),] # Remove irrelevant row
fish.2021 <- dplyr::select(fish.2021, -c(1, 3:11)) # Remove irrelevant columns
fish.2021$Species <- sub("\\.", "", fish.2021$Species) # Remove points from species names

## Merge all years
fish.2017_2022 <- left_join(fish.2018, fish.2019, by = "Species")
fish.2017_2022 <- left_join(fish.2017_2022, fish.2020, by = "Species")
fish.2017_2022 <- left_join(fish.2017_2022, fish.2021, by = "Species")

## Get rid of the columns not needed (pre-calculated biomasses)
fish.2017_2022 <- fish.2017_2022[, -grep(pattern= 'g_', colnames(fish.2017_2022))]
fish.2017_2022 <- fish.2017_2022[, -grep(pattern='kgha', colnames(fish.2017_2022))]
fish.2017_2022 <- fish.2017_2022[, -grep(pattern='TOT', colnames(fish.2017_2022))]

## Net NAs to 0 
fish.2017_2022[is.na(fish.2017_2022)] <- 0

## Set column names (NB: order of surveys won't match original Excel numbering anymore: start numbering at oldest survey years)
surveys.tot <- (ncol(fish.2017_2022) - 1)/13
colname <- c("Species", paste0(rep(c("1_", "2_", "3_", "4_", "5_", "6_", "7_", "8_", "9_", "10_", "11_", "12_", "Coloured_"),
                                     surveys.tot), rep(1:surveys.tot, each = 13)))
colnames(fish.2017_2022) <- colname

## Here try to sum all 10_ and 11_ and 12_, and add a column with the sum for later
for (i in 1:surveys.tot)
  {
  cols <- paste0(c("10_", "11_", "12_"), i)
  fish.2017_2022[[paste0("11num_", i)]] <- rowSums(fish.2017_2022[, cols])
  
  # Weighted mean column, safely handling sum == 0
  fish.2017_2022[[paste0("11size_", i)]] <- ifelse(
    fish.2017_2022[[paste0("11num_", i)]] == 0,
    0,
    (fish.2017_2022[[paste0("10_", i)]] * 75 +
     fish.2017_2022[[paste0("11_", i)]] * 125 +
     fish.2017_2022[[paste0("12_", i)]] * 175) /
      fish.2017_2022[[paste0("11num_", i)]]
  )
  
  # Reorder columns to place 11num_i and 11size_i after 12_i
  col_order <- names(fish.2017_2022)
  idx_12 <- which(col_order == paste0("12_", i))
  col_order <- append(col_order, c(paste0("11num_", i), paste0("11size_", i)), after = idx_12)
  col_order <- col_order[!duplicated(col_order)]
  fish.2017_2022 <- fish.2017_2022[, col_order]
}

## Go to long format
fish.2017_2022 <- setDT(fish.2017_2022)
fish.2017_2022 <- melt(fish.2017_2022, id.vars = 'Species', variable.name = 'SurveyNo', 
            measure.vars = patterns('^1_', '^2_', '^3_', '^4_', '^5_', '^6_',
                                    '^7_', '^8_', '^9_', '^10_', '^11_', '^12_','^11num_','^11size_', '^Coloured_'),
            value.name = c('1.25', '3.75', '6.25', '8.75', '12.5', '17.5',
                           '25', '35', '45', '75', '125', '175','65', 'SizeClass_11', 'Coloured'))
fish.2017_2022$Coloured[fish.2017_2022$Coloured == 0] <- 12 # Set non-coloured value (12) for missing data (new species)
fish.2017_2022$SurveyNo <- as.numeric(fish.2017_2022$SurveyNo)

# Get Size class from wide to long
fish.2017_2022 <- reshape2::melt(fish.2017_2022, id.vars = c('SurveyNo', 'Species', 'Coloured', 'SizeClass_11'), 
          measure.vars = c('1.25', '3.75', '6.25', '8.75', '12.5', '17.5', '25', '35', '45', '75', '125', '175','65'),
          variable.name = 'SizeClass', value.name = 'Abundance')

### Update taxonomy for re-named species
fish.2017_2022$Species <- ifelse(fish.2017_2022$Species == "Carangoides ferdau", "Ferdauia ferdau",
                 ifelse(fish.2017_2022$Species == "Carangoides fulvoguttatus", "Turrum fulvoguttatum",       
                 ifelse(fish.2017_2022$Species == "Carangoides orthogrammus", "Ferdauia orthogrammus",       
                 ifelse(fish.2017_2022$Species == "Cetoscarus bicolor", "Cetoscarus ocellatus",       
                 ifelse(fish.2017_2022$Species == "Chromis dimidiata", "Pycnochromis fieldi",       
                 ifelse(fish.2017_2022$Species == "Chromis lepidolepis", "Azurina lepidolepis",       
                 ifelse(fish.2017_2022$Species == "Chromis nigrura", "Pycnochromis nigrurus",       
                 ifelse(fish.2017_2022$Species == "Chromis xutha", "Pycnochromis agilis",       
                 ifelse(fish.2017_2022$Species == "Dascyllus aruanus", "Dascyllus abudafur",       
                 ifelse(fish.2017_2022$Species == "Heteropriacanthus cruentatus", "Heteropriacanthus carolinus",       
                 ifelse(fish.2017_2022$Species == "Neotrygon kuhlii", "Neotrygon indica",       
                 ifelse(fish.2017_2022$Species == "Plectroglyphidodon lacrymatus", "Stegastes lacrymatus",       
                 ifelse(fish.2017_2022$Species == "Pseudanthias evansi", "Mirolabrichthys evansi",       
                 ifelse(fish.2017_2022$Species == "Ulua mentalis", "Atropis mentalis",
                 ifelse(fish.2017_2022$Species == "Unknown parrotfish", "Scarus sp",
                 ifelse(fish.2017_2022$Species == "Pomacentrus aquilus", "Chrysiptera sp", 
                 ifelse(fish.2017_2022$Species == "Pomacentrus philippinus", "Neopomacentrus cyanomos", 
                 ifelse(fish.2017_2022$Species == "Pempheris nesogallica", "Pempheris sp", 
                 ifelse(fish.2017_2022$Species == "Upeneus tragula", "Upeneus heemstra",                         
                        fish.2017_2022$Species)))))))))))))))))))
fish.2017_2022 <- subset(fish.2017_2022, Species != "NEW SPECIES")

# Pomacentrus aquilus & phillipinus as well as Pempheris nesogallica are special cases, because they have to get merged with an already existing entry, being probably misidentified earlier. First we determine whether to add up the counts, based on if and when they were observed.
# Target species
target_species <- c("Chrysiptera sp", "Neopomacentrus cyanomos", "Pempheris sp")

fish.2017_2022 <- fish.2017_2022 %>%
  # Step 1: calculate sum11 and sum12 for each species per SurveyNo
  group_by(SurveyNo, Species) %>%
  mutate(
    sum11 = if_else(Species %in% target_species,
                    sum(Abundance[Coloured == 11], na.rm = TRUE),
                    NA_real_),
    sum12 = if_else(Species %in% target_species,
                    sum(Abundance[Coloured == 12], na.rm = TRUE),
                    NA_real_)
  ) %>%
  ungroup() %>%
  
  # Step 2: filter rows according to the same rules as before
  filter(
    !(Species %in% target_species & (
        (sum11 > 0 & sum12 > 0 & Coloured == 11) |
        (sum11 > 0 & sum12 == 0 & Coloured == 12) |
        (sum11 == 0 & sum12 > 0 & Coloured == 11) |
        (sum11 == 0 & sum12 == 0 & Coloured == 11)
      ))
  ) %>%
  dplyr::select(-sum11, -sum12) %>%
  
  # Step 3: combine abundances for duplicate SizeClass rows within target species
  group_by(SurveyNo, Species, SizeClass) %>%
  mutate(
    Abundance = if_else(Species %in% target_species, sum(Abundance, na.rm = TRUE), Abundance)
  ) %>%
  filter(!(Species %in% target_species & duplicated(SizeClass))) %>%
  ungroup()

# ==== Meta data 2017-2022 ====
## Load
meta.2018 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2017-2018.xlsm", sheet = "Data")) # 2018
meta.2019 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2019.xlsm", sheet = "Data")) # 2019 
meta.2020 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2020.xlsm", sheet = "Data")) # 2020
meta.2021 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2021-2022.xlsm", sheet = "Data")) # 2021 
meta.2021 <- meta.2021[!is.na(meta.2021$Date),] # Remove empty rows

## Merge years
meta.2017_2022 <- rbind(meta.2018, meta.2019, meta.2020, meta.2021)

## Clean up
meta.2017_2022$SurveyNo <- as.numeric(seq(1, surveys.tot, by = 1))
meta.2017_2022 <- meta.2017_2022[,c("SurveyNo", "Date", "Location", "Transect", "Observer", "Radius", "Area", "Comments")] # Select columns

## Add meta data to main dataframe
fish.2017_2022 <- merge(fish.2017_2022, meta.2017_2022, all.x=T, by='SurveyNo')

# ==== Species information ====
## Load and clean
specieslist <- as.data.frame(read_excel("Raw data/SpeciesList_2025-11.xlsx", sheet = "SpeciesList"))
specieslist$Species <- sub("\\.", "", specieslist$Species) # Remove points from species names
specieslist <- dplyr::select(specieslist, c("Species", "Diet", "DietH", "a", "b"))

## Add species data to main dataframe
fish.2017_2022 <- merge(fish.2017_2022, specieslist, all.x=T, by='Species')

# ==== Calculate biomass ====
# Make all rows numeric for biomass calculations & remove duplicates for Sizeclass 11
fish.2017_2022$SizeClass <- as.numeric(as.character(fish.2017_2022$SizeClass))
fish.2017_2022$SizeClass_11 <- ifelse(fish.2017_2022$SizeClass == 65, fish.2017_2022$SizeClass_11, 0)

# Select all rows where SizeClass is 65 (Class 11-proxy)
temp_df <- fish.2017_2022[fish.2017_2022$SizeClass %in% c("65"), ]

# Remove these rows from the original dataframe
fish.2017_2022 <- fish.2017_2022[!fish.2017_2022$SizeClass %in% c("65"), ]

## Calculate biomass using the length-weight formula W = a * L^b, multiply per abundance and standardize to kg/ha
fish.2017_2022$Biomass_kgha <- ((((fish.2017_2022$a * (fish.2017_2022$SizeClass ^ fish.2017_2022$b)) * fish.2017_2022$Abundance)/ fish.2017_2022$Area)/1000)* 10000

## Standardize abundance
fish.2017_2022$Abundance_m2 <- fish.2017_2022$Abundance/fish.2017_2022$Area

# Standardize abundance for the temporary file with sizeclass 11
temp_df$Abundance_m2 <-temp_df$Abundance/temp_df$Area

# Calculate biomass for sizeclass 11
biomass_sum <- fish.2017_2022 %>%
  filter(SizeClass %in% c(75, 125, 175)) %>%
  group_by(SurveyNo, Species) %>%
  summarise(total_biomass = sum(Biomass_kgha, na.rm = TRUE), .groups = "drop")

# Join biomass_sum to temp_df by SurveyNo and Species
temp_df <- temp_df %>%
  left_join(biomass_sum, by = c("SurveyNo", "Species"))

# Rename the summed column to Biomass_kgha
temp_df <- temp_df %>%
  rename(Biomass_kgha = total_biomass)

#Add the temporary dataframe back to the original dataframe
fish.2017_2022 <- bind_rows(fish.2017_2022, temp_df)
rm(temp_df)

# Considering there is no class 10 in the old system, we use the removable class 75 to become 55.
fish.2017_2022$SizeClass[fish.2017_2022$SizeClass == "75"] <- "55"
fish.2017_2022$Abundance[fish.2017_2022$SizeClass == "55"] <- 0
fish.2017_2022$Abundance_m2[fish.2017_2022$SizeClass == "55"] <- 0
fish.2017_2022$Biomass_kgha[fish.2017_2022$SizeClass == "55"] <- 0
fish.2017_2022$SizeClass_11[fish.2017_2022$SizeClass == "55"] <- 0

# Remove rows where SizeClass is 125, or 175 (75 has been used to make missing 55 (Class 10) row)
fish.2017_2022 <- fish.2017_2022 %>%
  filter(!SizeClass %in% c("125", "175"))

## Cleanup
fish.2017_2022 <- dplyr::select(fish.2017_2022, - c("a", "b"))

# ---- DATA 2023-2025 ----
# ---2023-2024---
# Get raw data and formats
fishRaw.2023 <- xlsx_cells("Raw data/Fish surveys_DATABASE_2023-2024_0.xlsx") # Includes all sheets and styles
fish.2023 <- subset(fishRaw.2023, sheet == "INPUT Sheet") # Data including both Non & Instantaneous observations)
fish.2023format <- xlsx_formats("Raw data/Fish surveys_DATABASE_2023-2024_0.xlsx") # Formats of all sheets

# Identify non-instantaneous data
## Identify coloured cells
Fish.2023_ColouredCells <- fish.2023 %>% 
  filter(local_format_id %in% which(!is.na(fish.2023format$local$fill$patternFill$fgColor$rgb))) %>%
  dplyr::select(address, row, col, data_type)
## Label them 12 (instantaneous) or 11 (non-instantaneous)
fish.2023$Coloured <- ifelse(fish.2023$address %in% Fish.2023_ColouredCells$address, 11, 12)

## Tidy data
fish.2023 <- subset(fish.2023, row > 2) # Remove first two rows row (survey number & size classes)
fish.2023 <- dplyr::select(fish.2023, c("row", "col", "character", "numeric", "Coloured")) # Select relevant columns
Fish.2023_speciesList <- na.omit(fish.2023$character) # Save species list for later use
fish.2023 <- dplyr::select(fish.2023, -c("character")) # Remove species column
fish.2023 <- subset(fish.2023, col > 1) # Remove species column values
fish.2023$row <- fish.2023$row - 2 # Renumber rows to start at 1
fish.2023$col <- fish.2023$col - 1 # Renumber columns to start at 1

# To wide format
fish.2023 <- as.data.frame(fish.2023) # Go from tibble back to dataframe
fish.2023 <- reshape(fish.2023, idvar = c("row"), timevar = "col", direction = "wide") # To wide format (takes 2 mins)

# Set column names
fish.2023_surveys.tot <- (ncol(fish.2023) - 1)/24
fish.2023_colname <- c("Species", paste0(rep(c("c1_", "Coloured_c1_", "c2_", "Coloured_c2_", "c3_", "Coloured_c3_", "c4_", "Coloured_c4_", "c5_", "Coloured_c5_", "c6_", "Coloured_c6_", "c7_", "Coloured_c7_", "c8_", "Coloured_c8_", "c9_", "Coloured_c9_", "c10_", "Coloured_c10_", "c11num_", "Coloured_c11num_", "c11size_", "Coloured_c11size_"), fish.2023_surveys.tot), rep(1:fish.2023_surveys.tot, each = 24)))
colnames(fish.2023) <- fish.2023_colname

# To long format
fish.2023 <- setDT(fish.2023)
fish.2023 <- melt(fish.2023, 
            id.vars = 'Species', variable.name = 'SurveyNo', 
            measure.vars = patterns('^c1_', "Coloured_c1_", '^c2_', "Coloured_c2_", '^c3_', "Coloured_c3_", '^c4_', "Coloured_c4_", '^c5_', "Coloured_c5_", '^c6_', "Coloured_c6_", '^c7_', "Coloured_c7_", '^c8_', "Coloured_c8_", '^c9_', "Coloured_c9_", '^c10_', "Coloured_c10_", '^c11num_', "Coloured_c11num_", '^c11size_', "Coloured_c11size_"),
            value.name = c('1.25', 'Coloured_1.25', '3.75', 'Coloured_3.75', '6.25', 'Coloured_6.25', '8.75', 'Coloured_8.75', '12.5', 'Coloured_12.5', '17.5',  'Coloured_17.5', '25', 'Coloured_25', '35', 'Coloured_35', '45', 'Coloured_45', '55', 'Coloured_55',  '65',  'Coloured_65', 'SizeClass_11',  'Coloured_SizeClass_11'))

# Check & summarize if any of the size classes had a coloured cell
fish.2023$Coloured <- ifelse(fish.2023$Coloured_1.25 + fish.2023$Coloured_3.75 + fish.2023$Coloured_6.25 + fish.2023$Coloured_8.75 + fish.2023$Coloured_12.5 + fish.2023$Coloured_17.5 + fish.2023$Coloured_25 + fish.2023$Coloured_35 + fish.2023$Coloured_45 + fish.2023$Coloured_55 + fish.2023$Coloured_65 + fish.2023$Coloured_SizeClass_11 == 144, 12, 11)
fish.2023 <- dplyr::select(fish.2023, -c("Coloured_1.25", "Coloured_3.75", "Coloured_6.25", "Coloured_8.75", "Coloured_12.5", "Coloured_17.5", "Coloured_25", "Coloured_35", "Coloured_45", "Coloured_55", "Coloured_65", "Coloured_SizeClass_11"))

# Get Size class from wide to long
fish.2023 <- reshape2::melt(fish.2023, id.vars = c('SurveyNo', 'Species', 'Coloured', 'SizeClass_11'), 
          measure.vars = c('1.25', '3.75', '6.25', '8.75', '12.5', '17.5', '25', '35', '45', '55', '65'),
          variable.name = 'SizeClass', value.name = 'Abundance')

#Remove duplicates in SizeClass 65 (Class 11-proxy)
fish.2023$SizeClass_11 <- ifelse(fish.2023$SizeClass == 65, fish.2023$SizeClass_11, 0)

# ==== Add meta data ====
## Re-add species names in data frame
fish.2023$Species <- Fish.2023_speciesList # Added based on original order (!)
fish.2023$Species <- sub("\\.", "", fish.2023$Species) # Remove points from species names

### Update taxonomy for re-named or previously misidentified species
fish.2023$Species <-   ifelse(fish.2023$Species == "Pycnochromis dimidiatus", "Pycnochromis fieldi",
                       ifelse(fish.2023$Species == "Upeneus tragula", "Upeneus heemstra",
                              fish.2023$Species))

## Species metadata
fish.2023 <- merge(fish.2023, specieslist, all.x=T, by='Species') # Combine data and specieslist data frames
fish.2023$SizeClass <- as.numeric(paste(fish.2023$SizeClass)) # Set a numeric Length

## Add survey info
meta.2023 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2023-2024_0.xlsx", sheet = "Data")) 
meta.2023 <- meta.2023[!is.na(meta.2023$Date),] # Remove empty rows
colnames(meta.2023)[1] <- "SurveyNo" 
meta.2023 <- meta.2023[,c("SurveyNo", "Date", "Location", "Transect", "Observer", "Radius", "Area", "Comments")] # Select relevant columns
fish.2023 <- merge(fish.2023, meta.2023, all.x=T, by='SurveyNo')

# ==== Calculate biomass ====
## Size class 65 serves as a proxy for the largest class, the actual size is taken from the SizeClass_11 variable
fish.2023$Biomass_kgha <- ifelse(
  fish.2023$SizeClass == 65,
  ((((fish.2023$a * (fish.2023$SizeClass_11 ^ fish.2023$b)) *
      fish.2023$Abundance) / fish.2023$Area) / 1000) * 10000,
  ((((fish.2023$a * (fish.2023$SizeClass ^ fish.2023$b)) *
      fish.2023$Abundance) / fish.2023$Area) / 1000) * 10000
)

## Standardize abundance
fish.2023$Abundance_m2 <- fish.2023$Abundance/fish.2023$Area

## Cleanup
fish.2023 <- dplyr::select(fish.2023, - c("a", "b"))
fish.2023 <- fish.2023 %>% drop_na(Abundance_m2) # Drop empty rows for surveys not yet done

# ---2024-2025---
# Change empty cells into zeros (needed to correctly read in the data in consecutive steps)
## Read observation block only (starting from row 3, column 2)
input_file <- "Raw data/Fish surveys_DATABASE_2024-2025 (2025-05).xlsx"   # your original, styled file
raw_obs <- read_excel(input_file, sheet = "INPUT Sheet", col_names = FALSE) # Takes ~2 mins
obs_block <- raw_obs[-c(1, 2), -1, drop = FALSE]  # remove first two rows and first column
obs_block <- as.data.frame(obs_block, stringsAsFactors = FALSE)

# Step 2: Clean observation block (convert to numeric, replace blanks with 0)
obs_block[] <- lapply(obs_block, function(col) {
  col[col == ""] <- NA
  suppressWarnings(as.numeric(replace(col, is.na(col), 0)))
})

# Step 3: Load the workbook with formatting intact
wb <- loadWorkbook(input_file) # Takes a few minutes

# Step 4: Write cleaned values into the same cells (preserving formatting)
writeData(
  wb, 
  sheet = "INPUT Sheet", 
  x = obs_block, 
  startRow = 3, 
  startCol = 2, 
  colNames = FALSE
)

## Step 5: Save updated file
saveWorkbook(wb, "Raw data/Fish surveys_DATABASE_2024-2025 (2025-05)_0.xlsx", overwrite = TRUE)

# Get raw data and formats
fishRaw.2024 <- xlsx_cells("Raw data/Fish surveys_DATABASE_2024-2025 (2025-05)_0.xlsx") # Includes all sheets and styles
fish.2024 <- subset(fishRaw.2024, sheet == "INPUT Sheet") # Data including both Non & Instantaneous observations)
fish.2024format <- xlsx_formats("Raw data/Fish surveys_DATABASE_2024-2025 (2025-05)_0.xlsx") # Formats of all sheets

# Identify non-instantaneous data
## Identify coloured cells
Fish.2024_ColouredCells <- fish.2024 %>% 
  filter(local_format_id %in% which(!is.na(fish.2024format$local$fill$patternFill$fgColor$rgb))) %>%
  dplyr::select(address, row, col, data_type)
## Label them 12 (instantaneous) or 11 (non-instantaneous)
fish.2024$Coloured <- ifelse(fish.2024$address %in% Fish.2024_ColouredCells$address, 11, 12)

## Tidy data
fish.2024 <- subset(fish.2024, row > 2) # Remove first two rows row (survey number & size classes)
fish.2024 <- dplyr::select(fish.2024, c("row", "col", "character", "numeric", "Coloured")) # Select relevant columns
Fish.2024_speciesList <- na.omit(fish.2024$character) # Save species list for later use
fish.2024 <- dplyr::select(fish.2024, -c("character")) # Remove species column
fish.2024 <- subset(fish.2024, col > 1) # Remove species column values
fish.2024$row <- fish.2024$row - 2 # Renumber rows to start at 1
fish.2024$col <- fish.2024$col - 1 # Renumber columns to start at 1

# To wide format
fish.2024 <- as.data.frame(fish.2024) # Go from tibble back to dataframe
fish.2024 <- reshape(fish.2024, idvar = c("row"), timevar = "col", direction = "wide") # To wide format (takes 2 mins)

# Set column names
fish.2024_surveys.tot <- (ncol(fish.2024) - 1)/24
fish.2024_colname <- c("Species", paste0(rep(c("c1_", "Coloured_c1_", "c2_", "Coloured_c2_", "c3_", "Coloured_c3_", "c4_", "Coloured_c4_", "c5_", "Coloured_c5_", "c6_", "Coloured_c6_", "c7_", "Coloured_c7_", "c8_", "Coloured_c8_", "c9_", "Coloured_c9_", "c10_", "Coloured_c10_", "c11num_", "Coloured_c11num_", "c11size_", "Coloured_c11size_"), fish.2024_surveys.tot), rep(1:fish.2024_surveys.tot, each = 24)))
colnames(fish.2024) <- fish.2024_colname

# To long format
fish.2024 <- setDT(fish.2024)
fish.2024 <- melt(fish.2024, 
            id.vars = 'Species', variable.name = 'SurveyNo', 
            measure.vars = patterns('^c1_', "Coloured_c1_", '^c2_', "Coloured_c2_", '^c3_', "Coloured_c3_", '^c4_', "Coloured_c4_", '^c5_', "Coloured_c5_", '^c6_', "Coloured_c6_", '^c7_', "Coloured_c7_", '^c8_', "Coloured_c8_", '^c9_', "Coloured_c9_", '^c10_', "Coloured_c10_", '^c11num_', "Coloured_c11num_", '^c11size_', "Coloured_c11size_"),
            value.name = c('1.25', 'Coloured_1.25', '3.75', 'Coloured_3.75', '6.25', 'Coloured_6.25', '8.75', 'Coloured_8.75', '12.5', 'Coloured_12.5', '17.5',  'Coloured_17.5', '25', 'Coloured_25', '35', 'Coloured_35', '45', 'Coloured_45', '55', 'Coloured_55',  '65',  'Coloured_65', 'SizeClass_11',  'Coloured_SizeClass_11'))

# Check & summarize if any of the size classes had a coloured cell
fish.2024$Coloured <- ifelse(fish.2024$Coloured_1.25 + fish.2024$Coloured_3.75 + fish.2024$Coloured_6.25 + fish.2024$Coloured_8.75 + fish.2024$Coloured_12.5 + fish.2024$Coloured_17.5 + fish.2024$Coloured_25 + fish.2024$Coloured_35 + fish.2024$Coloured_45 + fish.2024$Coloured_55 + fish.2024$Coloured_65 + fish.2024$Coloured_SizeClass_11 == 144, 12, 11)
fish.2024 <- dplyr::select(fish.2024, -c("Coloured_1.25", "Coloured_3.75", "Coloured_6.25", "Coloured_8.75", "Coloured_12.5", "Coloured_17.5", "Coloured_25", "Coloured_35", "Coloured_45", "Coloured_55", "Coloured_65", "Coloured_SizeClass_11"))

# Get Size class from wide to long
fish.2024 <- reshape2::melt(fish.2024, id.vars = c('SurveyNo', 'Species', 'Coloured', 'SizeClass_11'), 
          measure.vars = c('1.25', '3.75', '6.25', '8.75', '12.5', '17.5', '25', '35', '45', '55', '65'),
          variable.name = 'SizeClass', value.name = 'Abundance')

#Remove duplicates in SizeClass 65 (Class 11-proxy)
fish.2024$SizeClass_11 <- ifelse(fish.2024$SizeClass == 65, fish.2024$SizeClass_11, 0)

# ==== Add meta data ====
## Re-add species names in data frame
fish.2024$Species <- Fish.2024_speciesList # Added based on original order (!)
fish.2024$Species <- sub("\\.", "", fish.2024$Species) # Remove points from species names

### Update taxonomy for re-named or previously misidentified species
fish.2024$Species <-   ifelse(fish.2024$Species == "Pycnochromis dimidiatus", "Pycnochromis fieldi",
                       ifelse(fish.2024$Species == "Upeneus tragula", "Upeneus heemstra",
                              fish.2024$Species))

## Species metadata
fish.2024 <- merge(fish.2024, specieslist, all.x=T, by='Species') # Combine data and specieslist data frames
fish.2024$SizeClass <- as.numeric(paste(fish.2024$SizeClass)) # Set a numeric Length

## Add survey info
meta.2024 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2024-2025 (2025-05)_0.xlsx", sheet = "Data")) 
meta.2024 <- meta.2024[!is.na(meta.2024$Date),] # Remove empty rows
colnames(meta.2024)[1] <- "SurveyNo" 
meta.2024 <- meta.2024[,c("SurveyNo", "Date", "Location", "Transect", "Observer", "Radius", "Area", "Comments")] # Select relevant columns
fish.2024 <- merge(fish.2024, meta.2024, all.x=T, by='SurveyNo')

# ==== Calculate biomass ====
## Size class 65 serves as a proxy for the largest class, the actual size is taken from the SizeClass_11 variable
fish.2024$Biomass_kgha <- ifelse(
  fish.2024$SizeClass == 65,
  ((((fish.2024$a * (fish.2024$SizeClass_11 ^ fish.2024$b)) *
      fish.2024$Abundance) / fish.2024$Area) / 1000) * 10000,
  ((((fish.2024$a * (fish.2024$SizeClass ^ fish.2024$b)) *
      fish.2024$Abundance) / fish.2024$Area) / 1000) * 10000
)

## Standardize abundance
fish.2024$Abundance_m2 <- fish.2024$Abundance/fish.2024$Area

## Cleanup
fish.2024 <- dplyr::select(fish.2024, - c("a", "b"))
fish.2024 <- fish.2024 %>% drop_na(Abundance_m2) # Drop empty rows for surveys not yet done

# ---2025-2026---

# Change empty cells into zeros (needed to correctly read in the data in consecutive steps)
## Read observation block only (starting from row 3, column 2)
input_file <- "Raw data/Fish surveys_DATABASE_2025-2026.xlsx"   # your original, styled file
raw_obs <- read_excel(input_file, sheet = "INPUT Sheet", col_names = FALSE) # Takes ~2 mins
obs_block <- raw_obs[-c(1, 2), -1, drop = FALSE]  # remove first two rows and first column
obs_block <- as.data.frame(obs_block, stringsAsFactors = FALSE)

# Step 2: Clean observation block (convert to numeric, replace blanks with 0)
obs_block[] <- lapply(obs_block, function(col) {
  col[col == ""] <- NA
  suppressWarnings(as.numeric(replace(col, is.na(col), 0)))
})

# Step 3: Load the workbook with formatting intact
wb <- loadWorkbook(input_file)

# Step 4: Write cleaned values into the same cells (preserving formatting)
writeData(
  wb, 
  sheet = "INPUT Sheet", 
  x = obs_block, 
  startRow = 3, 
  startCol = 2, 
  colNames = FALSE
)

## Step 5: Save updated file
saveWorkbook(wb, "Raw data/Fish surveys_DATABASE_2025-2026_0.xlsx", overwrite = TRUE)

# Get raw data and formats
fishRaw.2025 <- xlsx_cells("Raw data/Fish surveys_DATABASE_2025-2026_0.xlsx") # Includes all sheets and styles
fish.2025 <- subset(fishRaw.2025, sheet == "INPUT Sheet") # Data including both Non & Instantaneous observations)
fish.2025format <- xlsx_formats("Raw data/Fish surveys_DATABASE_2025-2026_0.xlsx") # Formats of all sheets

# Identify non-instantaneous data
## Identify coloured cells
Fish.2025_ColouredCells <- fish.2025 %>% 
  filter(local_format_id %in% which(!is.na(fish.2025format$local$fill$patternFill$fgColor$rgb))) %>%
  dplyr::select(address, row, col, data_type)
## Label them 12 (instantaneous) or 11 (non-instantaneous)
fish.2025$Coloured <- ifelse(fish.2025$address %in% Fish.2025_ColouredCells$address, 11, 12)

## Tidy data
fish.2025 <- subset(fish.2025, row > 2) # Remove first two rows row (survey number & size classes)
fish.2025 <- dplyr::select(fish.2025, c("row", "col", "character", "numeric", "Coloured")) # Select relevant columns
Fish.2025_speciesList <- na.omit(fish.2025$character) # Save species list for later use
fish.2025 <- dplyr::select(fish.2025, -c("character")) # Remove species column
fish.2025 <- subset(fish.2025, col > 1) # Remove species column values
fish.2025$row <- fish.2025$row - 2 # Renumber rows to start at 1
fish.2025$col <- fish.2025$col - 1 # Renumber columns to start at 1

# To wide format
fish.2025 <- as.data.frame(fish.2025) # Go from tibble back to dataframe
fish.2025 <- reshape(fish.2025, idvar = c("row"), timevar = "col", direction = "wide") # To wide format (takes 2 mins)

# Set column names
fish.2025_surveys.tot <- (ncol(fish.2025) - 1)/24
fish.2025_colname <- c("Species", paste0(rep(c("c1_", "Coloured_c1_", "c2_", "Coloured_c2_", "c3_", "Coloured_c3_", "c4_", "Coloured_c4_", "c5_", "Coloured_c5_", "c6_", "Coloured_c6_", "c7_", "Coloured_c7_", "c8_", "Coloured_c8_", "c9_", "Coloured_c9_", "c10_", "Coloured_c10_", "c11num_", "Coloured_c11num_", "c11size_", "Coloured_c11size_"), fish.2025_surveys.tot), rep(1:fish.2025_surveys.tot, each = 24)))
colnames(fish.2025) <- fish.2025_colname

# To long format
fish.2025 <- setDT(fish.2025)
fish.2025 <- melt(fish.2025, 
            id.vars = 'Species', variable.name = 'SurveyNo', 
            measure.vars = patterns('^c1_', "Coloured_c1_", '^c2_', "Coloured_c2_", '^c3_', "Coloured_c3_", '^c4_', "Coloured_c4_", '^c5_', "Coloured_c5_", '^c6_', "Coloured_c6_", '^c7_', "Coloured_c7_", '^c8_', "Coloured_c8_", '^c9_', "Coloured_c9_", '^c10_', "Coloured_c10_", '^c11num_', "Coloured_c11num_", '^c11size_', "Coloured_c11size_"),
            value.name = c('1.25', 'Coloured_1.25', '3.75', 'Coloured_3.75', '6.25', 'Coloured_6.25', '8.75', 'Coloured_8.75', '12.5', 'Coloured_12.5', '17.5',  'Coloured_17.5', '25', 'Coloured_25', '35', 'Coloured_35', '45', 'Coloured_45', '55', 'Coloured_55',  '65',  'Coloured_65', 'SizeClass_11',  'Coloured_SizeClass_11'))

# Check & summarize if any of the size classes had a coloured cell
fish.2025$Coloured <- ifelse(fish.2025$Coloured_1.25 + fish.2025$Coloured_3.75 + fish.2025$Coloured_6.25 + fish.2025$Coloured_8.75 + fish.2025$Coloured_12.5 + fish.2025$Coloured_17.5 + fish.2025$Coloured_25 + fish.2025$Coloured_35 + fish.2025$Coloured_45 + fish.2025$Coloured_55 + fish.2025$Coloured_65 + fish.2025$Coloured_SizeClass_11 == 144, 12, 11)
fish.2025 <- dplyr::select(fish.2025, -c("Coloured_1.25", "Coloured_3.75", "Coloured_6.25", "Coloured_8.75", "Coloured_12.5", "Coloured_17.5", "Coloured_25", "Coloured_35", "Coloured_45", "Coloured_55", "Coloured_65", "Coloured_SizeClass_11"))

# Get Size class from wide to long
fish.2025 <- reshape2::melt(fish.2025, id.vars = c('SurveyNo', 'Species', 'Coloured', 'SizeClass_11'), 
          measure.vars = c('1.25', '3.75', '6.25', '8.75', '12.5', '17.5', '25', '35', '45', '55', '65'),
          variable.name = 'SizeClass', value.name = 'Abundance')

#Remove duplicates in SizeClass 65 (Class 11-proxy)
fish.2025$SizeClass_11 <- ifelse(fish.2025$SizeClass == 65, fish.2025$SizeClass_11, 0)

# ==== Add meta data ====
## Re-add species names in data frame
fish.2025$Species <- Fish.2025_speciesList # Added based on original order (!)
fish.2025$Species <- sub("\\.", "", fish.2025$Species) # Remove points from species names

### Update taxonomy for re-named or previously misidentified species
fish.2025$Species <-   ifelse(fish.2025$Species == "Pycnochromis dimidiatus", "Pycnochromis fieldi",
                       ifelse(fish.2025$Species == "Upeneus tragula", "Upeneus heemstra",
                              fish.2025$Species))

## Species metadata
fish.2025 <- merge(fish.2025, specieslist, all.x=T, by='Species') # Combine data and specieslist data frames
fish.2025$SizeClass <- as.numeric(paste(fish.2025$SizeClass)) # Set a numeric Length

## Add survey info
meta.2025 <- as.data.frame(read_excel("Raw data/Fish surveys_DATABASE_2025-2026_0.xlsx", sheet = "Data")) 
meta.2025 <- meta.2025[!is.na(meta.2025$Date),] # Remove empty rows
colnames(meta.2025)[1] <- "SurveyNo" 
meta.2025 <- meta.2025[,c("SurveyNo", "Date", "Location", "Transect", "Observer", "Radius", "Area", "Comments")] # Select relevant columns
fish.2025 <- merge(fish.2025, meta.2025, all.x=T, by='SurveyNo')

# ==== Calculate biomass ====
## Size class 65 serves as a proxy for the largest class, the actual size is taken from the SizeClass_11 variable
fish.2025$Biomass_kgha <- ifelse(
  fish.2025$SizeClass == 65,
  ((((fish.2025$a * (fish.2025$SizeClass_11 ^ fish.2025$b)) *
      fish.2025$Abundance) / fish.2025$Area) / 1000) * 10000,
  ((((fish.2025$a * (fish.2025$SizeClass ^ fish.2025$b)) *
      fish.2025$Abundance) / fish.2025$Area) / 1000) * 10000
)

## Standardize abundance
fish.2025$Abundance_m2 <- fish.2025$Abundance/fish.2025$Area

## Cleanup
fish.2025 <- dplyr::select(fish.2025, - c("a", "b"))
fish.2025 <- fish.2025 %>% drop_na(Abundance_m2) # Drop empty rows for surveys not yet done

# ---- MERGE DATASETS ----
## Make column order match
### 2017-2022
fish.2017_2022 <- dplyr::select(fish.2017_2022, c("SurveyNo", "Species", "SizeClass_11", "SizeClass", "Abundance", "Abundance_m2", "Biomass_kgha",  "Coloured", "Diet", "DietH", "Date", "Location", "Transect", "Radius", "Area", "Observer", "Comments")) 

### 2023
fish.2023 <- dplyr::select(fish.2023, c("SurveyNo", "Species", "SizeClass_11", "SizeClass", "Abundance", "Abundance_m2", "Biomass_kgha",  "Coloured", "Diet", "DietH", "Date", "Location", "Transect","Radius", "Area", "Observer", "Comments")) 
## Update survey numbers to be continuous
fish.2023$SurveyNo <- as.numeric(fish.2023$SurveyNo)
SurveyNo2023 <- max(fish.2023$SurveyNo)
fish.2023$SurveyNo <- fish.2023$SurveyNo + surveys.tot
surveys.tot <- surveys.tot + SurveyNo2023

### 2024
fish.2024 <- dplyr::select(fish.2024, c("SurveyNo", "Species", "SizeClass_11", "SizeClass", "Abundance", "Abundance_m2", "Biomass_kgha",  "Coloured", "Diet", "DietH", "Date", "Location", "Transect","Radius", "Area", "Observer", "Comments"))
## Update survey numbers to be continuous
fish.2024$SurveyNo <- as.numeric(fish.2024$SurveyNo)
SurveyNo2024 <- max(fish.2024$SurveyNo)
fish.2024$SurveyNo <- fish.2024$SurveyNo + surveys.tot
surveys.tot <- surveys.tot + SurveyNo2024

### 2025
fish.2025 <- dplyr::select(fish.2025, c("SurveyNo", "Species", "SizeClass_11", "SizeClass", "Abundance", "Abundance_m2", "Biomass_kgha",  "Coloured", "Diet", "DietH", "Date", "Location", "Transect","Radius", "Area", "Observer", "Comments"))
## Update survey numbers to be continuous
fish.2025$SurveyNo <- as.numeric(fish.2025$SurveyNo)
SurveyNo2025 <- max(fish.2025$SurveyNo)
fish.2025$SurveyNo <- fish.2025$SurveyNo + surveys.tot
surveys.tot <- surveys.tot + SurveyNo2025

## Merge
fish <- rbind(fish.2017_2022, fish.2023, fish.2024, fish.2025)

# Match species
## Remove cryptic fish and unknown line
fish <- fish[!(fish$Species=='Atherinomorus sp' | fish$Species=='Ablabys binotatus' | fish$Species=='Amblyeleotris sp' |
        fish$Species=='Antennarius sp' | fish$Species=='Exallias brevis' | fish$Species=='Gymnomuraena zebra' |
        fish$Species=='Gymnothorax griseus' | fish$Species=='Gymnothorax javanicus' | fish$Species=='Gymnothorax meleagris' |
        fish$Species=='Gymnothorax sp' | fish$Species=='Inimicus filamentosus' | fish$Species=='Myrichthys colubrinus' |
        fish$Species=='Myrichthys maculosus' | fish$Species=='Paracirrhites arcatus' | fish$Species=='Paracirrhites forsteri' |
        fish$Species=='Parapercis hexophtalma' | fish$Species=='Parapercis sp' | fish$Species=='Scorpaenopsis sp' |
        fish$Species=='Scuticaria tigrina' | fish$Species=='Synodus sp' | fish$Species=='Trachyrhamphus bicoarctatus' |
        fish$Species=='Unknown blenny' | fish$Species=='Valenciennea helsdingenii' | fish$Species=='Valenciennea strigata' | 
        fish$Species=='Tylosurus crocodilus' |  fish$Species=='Plectropomus laevis' | fish$Species=='Unknown'),]

## Fill in missing species on both sides
### Set apart metadata first
meta.all <- dplyr::select(fish, c("SurveyNo", "Date", "Location", "Transect", "Radius", "Area", "Observer", "Comments"))
meta.all <- meta.all[!duplicated(meta.all[,c('SurveyNo')]),]
### Reduce dataframe to values only
fish <- dplyr::select(fish, -c("Diet", "DietH", "Date", "Location", "Transect", "Radius", "Area", "Observer", "Comments"))

### Fill in missing species with 0 values, or 12 in the case of Coloured
fish <- fish %>% complete(SurveyNo, Species, SizeClass)

fish$Abundance[is.na(fish$Abundance)] <- 0
fish$Abundance_m2[is.na(fish$Abundance_m2)] <- 0
fish$Biomass_kgha[is.na(fish$Biomass_kgha)] <- 0
fish$Coloured <- ifelse(fish$Coloured == -1, 12, fish$Coloured)

### Re-add meta surveys
fish <- left_join(fish, meta.all, by = "SurveyNo")
### Fill in Diet for newly added species
specieslist <- dplyr::select(specieslist, c("Species", "Diet", "DietH"))
fish <- left_join(fish, specieslist, by = "Species")

## Add transect info
transectinfo <- as.data.frame(read_excel("Raw data/Measurements timeline.xlsx", sheet = "Overview (yearly)"))
colnames(transectinfo)[1] <- "Transect"
transectinfo <- dplyr::select(transectinfo, c("Transect", "Type", "Site", "GPS", "Depth.MLLW", "Reef.dist_m", "AR.dist_m", "Date.created", "Area_m2"))
fish$Transect <- tolower(fish$Transect)
transectinfo$Transect <- tolower(transectinfo$Transect)

fish <- left_join(fish, transectinfo, by = "Transect")

## Replace the 65-proxy by the actual size of the largest class, which varies between species / survey. 
# If there is no fish in the largest class, keep 65 as a proxy.
fish <- fish %>%
  mutate(SizeClass = ifelse(SizeClass == 65 & Abundance > 0, SizeClass_11, SizeClass)) %>%
  dplyr::select(-SizeClass_11)

# Rename SizeClass to Size, considering it is not a class system now
fish <- fish %>% rename(Size = SizeClass)

#Make Size numeric to allow ordering to size
fish$Size <- as.numeric(fish$Size)

# Cleanup
fish <- fish %>% distinct()
fish$Type <- ifelse(fish$Transect == "na", "Reference", fish$Type)
fish$Site <- ifelse(fish$Transect == "na", fish$Location, 
             ifelse(is.na(fish$Site), fish$Location, fish$Site))
fish$Type <- ifelse(is.na(fish$Type), "Other", fish$Type)
colnames(fish)[which(names(fish) == "Type")] <- "Treatment"
fish$Patch.type <- ifelse(grepl("cma-l-", fish$Transect), "AR (L)",
                   ifelse(grepl("cma-xl-", fish$Transect), "AR (XL)",
                   ifelse(grepl("cma-xs-", fish$Transect), "AR (XS)",
                   ifelse(grepl("-bru-", fish$Transect), "BRU",
                   ifelse(grepl("-cage-", fish$Transect), "CAGE",       
                   ifelse(grepl("-cake-", fish$Transect), "CAKE",       
                   ifelse(grepl("-comp-", fish$Transect), "COMP",
                   ifelse(grepl("m-", fish$Transect), "MOSES (- coral)",       
                   ifelse(grepl("m+", fish$Transect), "MOSES (+ coral)",       
                   ifelse(grepl("m-c", fish$Transect), "MOSES (control)",  
                   ifelse(grepl("m-p", fish$Transect), "MOSES (pins)",       
                   ifelse(grepl("r-l-", fish$Transect), "Reference (L)",
                   ifelse(grepl("r-xl-", fish$Transect), "Reference (XL)",
                   ifelse(grepl("r-xs-", fish$Transect), "Reference (XS)",
                   ifelse(grepl("(?<!\\()f-r-", fish$Transect, perl=TRUE), "Control",
                   ifelse(grepl("(?<!\\()nt-r-", fish$Transect, perl=TRUE), "Control",
                   ifelse(grepl("\\(f-r-",fish$Transect),"Reference",
                   ifelse(grepl("\\(nt-r-",fish$Transect),"Reference",
                                "na"))))))))))))))))))    

fish$Date.created <- excel_numeric_to_date(as.numeric(fish$Date.created))
fish$Year.created <- year(fish$Date.created)
fish$Year <- year(fish$Date)

## Re-order dataframe
fish <- dplyr::select(fish, "SurveyNo", "Site", "Treatment", "Patch.type", "Transect", "Year.created", "Date.created", "GPS",
                            "Depth.MLLW", "Reef.dist_m", "AR.dist_m", "Area_m2","Radius", "Area","Observer", "Comments", "Year", "Date",
                            "Species", "Diet", "DietH", "Size", "Abundance", "Abundance_m2", "Biomass_kgha", "Coloured")

## Remove NAs before aggregating
fish <- fish %>%
  mutate_if(is.character, ~replace_na(., "na")) 
fish <- fish %>%
  mutate_if(is.numeric, ~replace_na(., -1)) 
fish <- dplyr::select(fish, -c("Date.created"))

## Write clean parquet file
write_parquet(fish, "Fish_All years.parquet")

## Clean environment
rm(fish, fish.2017_2022, fish.2018, fish.2019, fish.2020, fish.2021, fishRAW.2018, fishRAW.2019, fishRAW.2020, fishRAW.2021, meta.all,
   meta.2018, meta.2019, meta.2020, meta.2021, meta.2017_2022, specieslist, transectinfo, colname, 
   fish.2023, Fish.2023_ColouredCells, fish.2023format, fishRaw.2023, meta.2023, fish.2023_colname, fish.2023_surveys.tot, Fish.2023_speciesList, SurveyNo2023, 
   fish.2024, Fish.2024_ColouredCells, fish.2024format, fishRaw.2024, meta.2024, fish.2024_colname, fish.2024_surveys.tot, Fish.2024_speciesList,
   SurveyNo2024, 
   fish.2025, Fish.2025_ColouredCells, fish.2025format, fishRaw.2025, meta.2025, fish.2025_colname, fish.2025_surveys.tot, Fish.2025_speciesList,
   SurveyNo2025,
   surveys.tot, obs_block, raw_obs,  input_file, wb, fish_sizeclass, co, biomass_sum, col_order, cols, i, idx_12, target_species)

```

# Filtering RAW output to relevant information (adjust based on research interest)
```{r}
# Load data sets
fish <- read_parquet("Fish_All years.parquet")

# Remove irrelevant columns
fish <- fish %>%
  dplyr::select(-GPS, -Year.created, -Area_m2, -Diet)

# Select relevant surveys. The surveys from end of 2024 and start of 2025 (done on only the reference patches of both reefs) are excluded as they are right inbetween the surveys of 2023 and the new ones in 2025. I do not wish to have an inbetween yeargroup, as I am comparing three sets of complete surveys (all 60 reefs surveyed)
fish <- fish[fish$Patch.type %in% c("CAGE", "CAKE","BRU","COMP","Control","Reference") & fish$Year >= 2021 &
    !(fish$Date >= as.Date("2024-10-01") & fish$Date < as.Date("2025-02-01")),]

# Add a YearGroup variable, to compare between 2021, 2023 and 2025
fish$YearGroup <- ifelse(fish$Year %in% c(2021, 2022), "2021–2022",
                   ifelse(fish$Year %in% c(2023, 2024), "2023–2024",
                   ifelse(fish$Year == 2025, "2025", NA)))
fish <- fish %>% relocate(YearGroup, .after = Year)

# Set data types
fishtofactors <- c('SurveyNo', 'Site', 'Treatment', 'Patch.type', 'Transect', 'Observer', 'Year', 'YearGroup','Species', 'DietH', 'Size') 
fish[fishtofactors] <- lapply(fish[fishtofactors], factor)
rm(fishtofactors)
fish$AR.dist_m    <- as.numeric(trimws(fish$AR.dist_m))
fish$Reef.dist_m  <- as.numeric(trimws(fish$Reef.dist_m))

# Remove unused factors-
fish <- droplevels(fish)

# Exclude /practise surveys
fish <- fish[!grepl("exclude|wrong|exclude", fish$Comments, ignore.case = TRUE), ]

# Now we add some variables useful for modelling later on
## Combined variable for taking intra-survey Observer differences into account in the model
fish$TransectDate <- paste(fish$Transect, fish$Date, sep="_")

## Replace NA's in distances with 0's, these are excluded using :Treatment later. If we keep them NA, the entire row is excluded.
fish$Reefdistance <- fish$Reef.dist_m %>% replace(is.na(.), 0)
fish$ARdistance <- fish$AR.dist_m %>% replace(is.na(.), 0)

# Now we write a clean survey file for modelling
write_parquet(fish, "Fish_Clean.parquet")

# Get total list of relevant surveys
surveylist <- as.data.frame(unique(fish$SurveyNo))
names(surveylist) <- "SurveyNo"
surveylist <- surveylist %>% arrange(SurveyNo)

# Check average radius in last couple years, taking out duplicate surveys
fish_unique <- fish[!duplicated(fish[c("Transect", "Date")]), ]
aggregate(Radius ~ YearGroup, data = fish_unique,
          FUN = function(x) round(mean(x), 2))

```

# Load in data (once the above chunk is set to your taste, you only have to run this chunk when starting up again)
```{r}
fish <- read_parquet("Fish_Clean.parquet")
```
# Species richness
```{r}
# ---- DATA PREP ----
# Remove rows with non-herbivorous fish, and drop the "Other" level
Richness <- fish[fish$DietH != "Other",]
Richness <- droplevels(Richness)

all_combos <- expand_grid(
  SurveyNo = unique(Richness$SurveyNo),
  DietH = unique(Richness$DietH))

# Go from abundance to species richness, and bring back 0 values for groups without observations
## First store metadata
survey_meta <- Richness %>%
  dplyr::select(SurveyNo, Transect, Depth.MLLW, Reefdistance, ARdistance, Reef.dist_m, AR.dist_m, YearGroup, TransectDate, Patch.type, Treatment, Observer) %>%
  distinct()

## Count distinct herbivore species per herbivore guild per survey, and fill in 0 if there are none.
Richness <- Richness %>%
  group_by(SurveyNo, DietH) %>%
  summarise(GuildRichness = n_distinct(Species[Abundance > 0]),
            .groups = "drop") %>%
  right_join(all_combos, by = c("SurveyNo", "DietH")) 

## Bring back metadata lost in group_by
Richness <- Richness %>%
  left_join(survey_meta, by = "SurveyNo")
rm(survey_meta, all_combos)

```
## Pre-model plots
```{r}
# Add the different guilds together per survey
Richness_combined <- Richness %>%
  group_by(SurveyNo, Depth.MLLW, Treatment, Reef.dist_m, AR.dist_m) %>%
  summarise (Richness = sum(GuildRichness))

# Correlation between reef depth and species richness
plot(Richness_combined$Depth.MLLW, Richness_combined$Richness, xlab = "Depth", ylab = "Species richness", main = "Herbivore species richness vs Depth (covariate)")
abline(lm(Richness ~ Depth.MLLW, data = Richness_combined))
sum_lm <- summary (lm(Richness ~ Depth.MLLW, data = Richness_combined))
coef_lm <- sum_lm$coefficients
text(x = 7,
     y = 10,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from natural reef and species richness
Richness_noREF <- Richness_combined[Richness_combined$Treatment != "Reference",] 
plot(Richness_noREF$Reef.dist_m, Richness_noREF$Richness, xlab = "Reef distance", ylab = "Species richness", main = "Herbivore species richness vs distance from natural reef (covariate)")
abline(lm(Richness ~ Reef.dist_m, data = Richness_noREF))
sum_lm <- summary (lm(Richness ~ Reef.dist_m, data = Richness_noREF))
coef_lm <- sum_lm$coefficients
text(x = 23,
     y = 8,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from another AR and species richness
Richness_ARonly <- Richness_combined[Richness_combined$Treatment == "AR",] 
plot(Richness_ARonly$AR.dist_m, Richness_ARonly$Richness, xlab = "AR distance", ylab = "Species richness", main = "Herbivore species richness vs distance from another artifical reef (covariate)")
abline(lm(Richness ~ AR.dist_m, data = Richness_ARonly))
sum_lm <- summary (lm(Richness ~ AR.dist_m, data = Richness_ARonly))
coef_lm <- sum_lm$coefficients
text(x = 23,
     y = 8,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

rm(sum_lm)

# Conclusion: only Depth has a significant and considerable effect as a covariate, omit reef and AR distances here

```
## Statistical models
```{r richness}
# Version 5: Conway-Maxwell Poisson, with distances including NA values (to test significance of distance effects)
RmodelCMP3 <- glmmTMB(GuildRichness ~ Depth.MLLW + YearGroup * Patch.type + Reef.dist_m +  AR.dist_m + DietH + (1 | Transect) + (1 | TransectDate:Observer), data=Richness, family=compois())

# Version 7: Conway-Maxwell Poisson, but without distances modeled.
RmodelCMP5 <- glmmTMB(GuildRichness ~ Depth.MLLW + YearGroup * Patch.type + DietH + (1 | Transect) + (1 | TransectDate:Observer), data=Richness, family=compois())

# Version 8: Conway-Maxwell Poisson, but without distances modeled.
RmodelCMP6 <- glmmTMB(GuildRichness ~ Depth.MLLW + YearGroup * DietH + Patch.type + (1 | Transect) + (1 | TransectDate:Observer), data=Richness, family=compois())

# Version 8: Conway-Maxwell Poisson, but without distances modeled.
RmodelCMP7 <- glmmTMB(GuildRichness ~ Depth.MLLW + YearGroup * DietH + YearGroup * Patch.type + (1 | Transect) + (1 | TransectDate:Observer), data=Richness, family=compois())

# Look at model
Anova(RmodelCMP3) # Reef_distance and AR_distance are insignificant
Anova(RmodelCMP5) # YearGroup, Patch.type and DietH are all significant, and the interaction as well
Anova(RmodelCMP6)
Anova(RmodelCMP7) # YearGroup:DietH & YearGroup:Patch.type are significant. Also consider standalone YearGroup plot.

# # Normality, heteroscedasticity with DHARMa
Rsim_resCMP5 <- simulateResiduals(fittedModel = RmodelCMP5, re.form = NULL)
Rsim_resCMP6 <- simulateResiduals(fittedModel = RmodelCMP6, re.form = NULL)
Rsim_resCMP7 <- simulateResiduals(fittedModel = RmodelCMP7, re.form = NULL)

# # plot residuals
plot(Rsim_resCMP5)
plot(Rsim_resCMP6)
plot(Rsim_resCMP7)
testResiduals(Rsim_resCMP5)

testZeroInflation(Rsim_resCMP5) # <- Not significant
testCategorical(Rsim_resCMP5, catPred = Richness$Depth.MLLW)
testCategorical(Rsim_resCMP5, catPred = Richness$YearGroup)
testCategorical(Rsim_resCMP5, catPred = Richness$Patch.type)
testCategorical(Rsim_resCMP5, catPred = Richness$DietH)
```

## Plots & post-hoc
```{r}
# 1. YearGroup main effect
emm_year <- emmeans(RmodelCMP7, ~ YearGroup, type = "response")
cld_year <- cld(emm_year, Letters = letters)
emm_year_df <- as.data.frame(cld_year)
emm_year_df$.group <- trimws(emm_year_df$.group)

# 2. YearGroup:DietH interaction
emm_diet <- emmeans(RmodelCMP7, ~ YearGroup * DietH, type = "response")
cld_diet <- cld(emm_diet, by = "DietH", Letters = letters)
emm_diet_df <- as.data.frame(cld_diet)
emm_diet_df$.group <- trimws(emm_diet_df$.group)

# 3. YearGroup:Patch.type interaction
emm_patch <- emmeans(RmodelCMP7, ~ YearGroup * Patch.type, type = "response")
cld_patch <- cld(emm_patch, by = "Patch.type", Letters = letters)
emm_patch_df <- as.data.frame(cld_patch)
emm_patch_df$.group <- trimws(emm_patch_df$.group)

# Plot 1: YearGroup main effect
Rplot1 <- ggplot(emm_year_df, aes(x = YearGroup, y = response)) +
  geom_point(size = 3, color = "black") +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), 
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL), 
            vjust = -0.5, 
            size = 3) +
  labs(x = "Year Group", y = "Herbivore species richness",
      title = "Mean herbivore species richness per survey over time",
      subtitle = "Main effect (YearGroup × Guild and YearGroup × Patch.type interactions significant)") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Plot 2: Yeargroup x DietH interaction
Rplot2 <- ggplot(emm_diet_df, aes(x = DietH, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Herbivore guild", y = "Herbivore species richness", color = "Year Group",
       title = "Mean herbivore species richness per survey over time, by guild") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Plot 3: Yeargroup x patch.type interaction
Rplot3 <- ggplot(emm_patch_df, aes(x = Patch.type, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Patch Type", y = "Herbivore species richness", color = "Year Group",
       title = "Mean herbivore species richness per survey over time, by patch type") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Post-hoc
posthoc_year <- pairs(emm_year)
print("=== Plot 1: YearGroup comparisons ===")
# print(posthoc_year) <if you want to see all non-significant as well.
posthoc_year_df <- as.data.frame(posthoc_year)
posthoc_year_sig <- posthoc_year_df[posthoc_year_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_year_sig)

print("=== Plot 2: YearGroup comparisons within each Guild ===")
posthoc_diet_within <- pairs(emm_diet, by = "DietH")
# print(posthoc_diet_within)
posthoc_diet_within_df <- as.data.frame(posthoc_diet_within)
posthoc_diet_within_sig <- posthoc_diet_within_df[posthoc_diet_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_within_sig)

print("=== Plot 2: Guild comparisons within each YearGroup ===")
posthoc_diet_between <- pairs(emm_diet, by = "YearGroup")
# print(posthoc_diet_between)
posthoc_diet_between_df <- as.data.frame(posthoc_diet_between)
posthoc_diet_between_sig <- posthoc_diet_between_df[posthoc_diet_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_between_sig)

print("=== Plot 3: YearGroup comparisons within each Patch type ===")
posthoc_patch_within <- pairs(emm_patch, by = "Patch.type")
# print(posthoc_patch_within)
posthoc_patch_within_df <- as.data.frame(posthoc_patch_within)
posthoc_patch_within_sig <- posthoc_patch_within_df[posthoc_patch_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_within_sig)

print("=== Plot 3: Patch type comparisons within each YearGroup ===")
posthoc_patch_between <- pairs(emm_patch, by = "YearGroup")
# print(posthoc_patch_between)
posthoc_patch_between_df <- as.data.frame(posthoc_patch_between)
posthoc_patch_between_sig <- posthoc_patch_between_df[posthoc_patch_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_between_sig)

# Display plots
print(Rplot1)
print(Rplot2)
print(Rplot3)

```
## Old plots with stacked
```{r}
# Interaction effect Year x Patch.type
emm_int <- emmeans(RmodelCMP5, ~ YearGroup * Patch.type)
emm_df <- as.data.frame(emm_int)

ggplot(emm_df, aes(x = YearGroup,
                   y = emmean,
                   color = Patch.type)) +
  geom_point(position = position_dodge(width = 0.6), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.6),
                width = 0.2) +
  ylab("Predicted species richness") +
  xlab("Patch type") +
  ggtitle("Interaction: YearGroup × Patch.type") +
  theme_bw() +
  scale_colour_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733")) +
  scale_fill_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733"))
# Conclusion: differences between patch.types are different for each year group > interaction!

# Stacked bar chart
emm_df <- as.data.frame(emmeans(RmodelCMP5, ~ YearGroup + DietH, type = "response"))
emm_year <- emmeans(RmodelCMP5, ~ YearGroup)
cld_year <- cld(emm_year, Letters = letters, adjust = "sidak") # Letters show significance

emm_totals <- emm_df %>%
  group_by(YearGroup) %>%
  summarise(
    total = sum(response),
    SE_total = sqrt(sum(SE^2)),
    .groups = "drop"
  ) %>%
  mutate(
    LCL = total - 1.96 * SE_total,
    UCL = total + 1.96 * SE_total
  )

emm_totals <- emm_totals %>%
  left_join(cld_year[, c("YearGroup", ".group")], by = "YearGroup")

## Reorder DietH, largest at bottom
emm_df <- emm_df %>%
  group_by(YearGroup) %>%
  mutate(DietH = fct_reorder(DietH, response, .desc = FALSE)) %>%
  ungroup()

ggplot(emm_df, aes(x = YearGroup, y = response, fill = DietH)) +
  geom_bar(stat = "identity", width = 0.7) +  # stacked bars restored
  geom_errorbar(
    data = emm_totals,
    aes(x = YearGroup, ymin = LCL, ymax = UCL),
    inherit.aes = FALSE,
    width = 0.25,
    linewidth = 0.8
  ) +
  geom_text(
    data = emm_totals,
    aes(x = YearGroup, y = UCL + 0.05*max(UCL), label = .group),
    inherit.aes = FALSE
  ) +
  scale_fill_brewer(palette = "Set2", name = "Herbivore guild") +
  labs(
    x = "Yeargroup",
    y = "Species richness",
    title = "Predicted species richness per survey"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain")
  )

# Adding the Patch.type aspect
emm_df <- as.data.frame(emmeans(RmodelCMP5, ~ YearGroup * Patch.type + DietH, type = "response"))
emm_year <- emmeans(RmodelCMP5, ~ YearGroup | Patch.type)
cld_year <- cld(emm_year, Letters = letters, adjust = "sidak") %>%
  as.data.frame() # Letters show significance

emm_totals <- emm_df %>%
  group_by(YearGroup, Patch.type) %>%
  summarise(
    total = sum(response),
    SE_total = sqrt(sum(SE^2)),
    .groups = "drop"
  ) %>%
  mutate(
    LCL = total - 1.96 * SE_total,
    UCL = total + 1.96 * SE_total
  )

emm_totals <- emm_totals %>%
  left_join(cld_year[, c("YearGroup", "Patch.type", ".group")], by = c("YearGroup", "Patch.type"))

## Reorder DietH, largest at bottom
emm_df <- emm_df %>%
  group_by(YearGroup, Patch.type) %>%
  mutate(DietH = fct_reorder(DietH, response, .desc = FALSE)) %>%
  ungroup()

ggplot(emm_df, aes(x = YearGroup, y = response, fill = DietH)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_errorbar(
    data = emm_totals,
    aes(x = YearGroup, ymin = LCL, ymax = UCL),
    inherit.aes = FALSE,
    width = 0.25,
    linewidth = 0.8
  ) +
  geom_text(
    data = emm_totals,
    aes(x = YearGroup, y = UCL + 0.05*max(UCL), label = .group),
    inherit.aes = FALSE,
    size = 3
  ) +
  facet_wrap(~ Patch.type) +
  scale_fill_brewer(palette = "Set2", name = "Herbivore guild") +
  labs(
    x = "Yeargroup",
    y = "Species richness",
    title = "Predicted species richness per survey"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain"),
    strip.text = element_text(face = "plain")  # Make facet labels bold
  )
```
# Biomass
```{r}
# ---- DATA PREP ----
# Remove rows with no abundance or non-herbivorous fish
Biomass <- fish[fish$DietH != "Other" & fish$Coloured == 12,]
Biomass <- droplevels(Biomass)

all_combos <- expand_grid(
  SurveyNo = unique(Biomass$SurveyNo),
  DietH = unique(Biomass$DietH))

# Go from abundance to species Biomass, and bringing back 0 values for groups without observations
## First store metadata
survey_meta <- Biomass %>%
  dplyr::select(SurveyNo, Transect, Depth.MLLW, Reefdistance, ARdistance, Reef.dist_m, AR.dist_m, YearGroup, TransectDate, Patch.type, Treatment, Observer) %>%
  distinct()

Biomass <- Biomass %>%
  group_by(SurveyNo, DietH) %>%
  summarise(GuildBiomass = sum(Biomass_kgha),
            .groups = "drop") 

# Bring back the lost metadata 
Biomass <- Biomass %>%
  left_join(survey_meta, by = "SurveyNo")
rm(survey_meta, all_combos)
```
## Pre-model plots
```{r}
# Add the different guilds together per survey
Biomass_combined <- Biomass %>%
  group_by(SurveyNo, Depth.MLLW, Treatment, Reef.dist_m, AR.dist_m) %>%
  summarise (Biomass = sum(GuildBiomass))

# Correlation between reef depth and species richness
plot(Biomass_combined$Depth.MLLW, Biomass_combined$Biomass, xlab = "Depth", ylab = "Biomass (kg/ha)", ylim = c(0, 150), main = "Biomass vs Depth (covariate)")
abline(lm(Biomass ~ Depth.MLLW, data = Biomass_combined))
sum_lm <- summary (lm(Biomass ~ Depth.MLLW, data = Biomass_combined))
coef_lm <- sum_lm$coefficients
text(x = 7,
     y = 120,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from natural reef and species Biomass
Biomass_noREF <- Biomass_combined[Biomass_combined$Treatment != "Reference",] 
plot(Biomass_noREF$Reef.dist_m, Biomass_noREF$Biomass, xlab = "Reef distance", ylab = "Biomass (kg/ha)", ylim = c(0, 100), main = "Biomass vs distance from natural reef (covariate)")
abline(lm(Biomass ~ Reef.dist_m, data = Biomass_noREF))
sum_lm <- summary (lm(Biomass ~ Reef.dist_m, data = Biomass_noREF))
coef_lm <- sum_lm$coefficients
text(x = 20,
     y = 70,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 2 decimals
                     round(coef_lm[2,4],2),
                     "\ny = ",
                     #Round slope coefficient to 2 decimals
                     round(coef_lm[2,1],1),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from another AR and species Biomass
Biomass_ARonly <- Biomass_combined[Biomass_combined$Treatment == "AR",] 
plot(Biomass_ARonly$AR.dist_m, Biomass_ARonly$Biomass, xlab = "AR distance", ylab = "Biomass (kg/ha)", ylim = c(0, 150), main = "Biomass vs distance from another artifical reef (covariate)")
abline(lm(Biomass ~ AR.dist_m, data = Biomass_ARonly))
sum_lm <- summary (lm(Biomass ~ AR.dist_m, data = Biomass_ARonly))
coef_lm <- sum_lm$coefficients
text(x = 20,
     y = 120,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 2 decimals
                     round(coef_lm[2,4],2),
                     "\ny = ",
                     #Round slope coefficient to 2 decimals
                     round(coef_lm[2,1],1),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

rm(sum_lm)
```

## Statistical models
```{r}
# Version 3: log-link, first testing if Reef and AR distance without reference/control patches is significant
BmodelLoglink1 <- glmmTMB(GuildBiomass ~ Depth.MLLW + Reef.dist_m + AR.dist_m + YearGroup * Patch.type + DietH + (1 | Transect) + (1 | TransectDate:Observer), data = Biomass, family = tweedie(link="log"))

# Version 6: v3, taking only Reefdistance with proxies at reference
BmodelLoglink4 <- glmmTMB(GuildBiomass ~ Depth.MLLW + Reefdistance + YearGroup * Patch.type + DietH + (1 | Transect) + (1 | TransectDate:Observer), data = Biomass, dispformula = ~ DietH, family = tweedie(link="log"))

# Version 8: Two-way with YearGroup * DietH
BmodelLoglink6 <- glmmTMB(GuildBiomass ~ Depth.MLLW + YearGroup * DietH + Patch.type + (1 | Transect) + (1 | TransectDate:Observer), data = Biomass, family = tweedie(link="log"))

# Version 9: Two two-way with YearGroup * DietH & Yeargroup * Patch.type
BmodelLoglink7 <- glmmTMB(GuildBiomass ~ Depth.MLLW + YearGroup * DietH + YearGroup * Patch.type + (1 | Transect) + (1 | TransectDate:Observer), data = Biomass, family = tweedie(link="log"))

# Look at model
Anova(BmodelLoglink1) #<- Reef_distance is significant
summary(BmodelLoglink4)$coefficients$cond #<- Coefficient of Reefdistance is small, but has an influence: keeping
Anova(BmodelLoglink4) # Patch.type and DietH are significant, YearGroup and interaction aren't.
Anova(BmodelLoglink6) # Now DietH, Patch.type and the interaction YearGroup:DietH are significant.
Anova(BmodelLoglink7) # YearGroup:DietH & YearGroup:Patch.type are significant. Also consider standalone YearGroup plot.
 
# Normality & homoscedasticity for DHARMa
Bsim_resLoglink4 <- simulateResiduals(fittedModel = BmodelLoglink4, re.form = NULL)
Bsim_resLoglink6 <- simulateResiduals(fittedModel = BmodelLoglink6, re.form = NULL)
Bsim_resLoglink7 <- simulateResiduals(fittedModel = BmodelLoglink7, re.form = NULL)

# plot residuals
plot(Bsim_resLoglink4)
plot(Bsim_resLoglink6)
plot(Bsim_resLoglink7)
```
## Plots and post-hoc
```{r}
# 1. YearGroup main effect
emm_year <- emmeans(BmodelLoglink7, ~ YearGroup, type = "response")
cld_year <- cld(emm_year, Letters = letters)
emm_year_df <- as.data.frame(cld_year)
emm_year_df$.group <- trimws(emm_year_df$.group)

# 2. YearGroup:DietH interaction
emm_diet <- emmeans(BmodelLoglink7, ~ YearGroup * DietH, type = "response")
cld_diet <- cld(emm_diet, by = "DietH", Letters = letters)
emm_diet_df <- as.data.frame(cld_diet)
emm_diet_df$.group <- trimws(emm_diet_df$.group)

# 3. YearGroup:Patch.type interaction
emm_patch <- emmeans(BmodelLoglink7, ~ YearGroup * Patch.type, type = "response")
cld_patch <- cld(emm_patch, by = "Patch.type", Letters = letters)
emm_patch_df <- as.data.frame(cld_patch)
emm_patch_df$.group <- trimws(emm_patch_df$.group)

# Plot 1: YearGroup main effect
Bplot1 <- ggplot(emm_year_df, aes(x = YearGroup, y = response)) +
  geom_point(size = 3, color = "black") +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), 
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL), 
            vjust = -0.5, 
            size = 3) +
  labs(x = "Year Group", y = "Herbivore biomass (kg/ha)",
       title = "Mean herbivore biomass per survey over time",
      subtitle = "Main effect (YearGroup × Guild and YearGroup × Patch.type interactions significant)") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Plot 2: Yeargroup x DietH interaction
Bplot2 <- ggplot(emm_diet_df, aes(x = DietH, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Herbivore guild", y = "Herbivore biomass (kg/ha)", color = "Year Group",
       title = "Mean herbivore biomass per survey over time, by guild") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Plot 3: Yeargroup x patch.type interaction
Bplot3 <- ggplot(emm_patch_df, aes(x = Patch.type, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Patch Type", y = "Herbivore biomass (kg/ha)", color = "Year Group",
       title = "Mean herbivore biomass per survey over time, by patch type") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Post-hoc
posthoc_year <- pairs(emm_year)
print("=== Plot 1: YearGroup comparisons ===")
# print(posthoc_year) <if you want to see all non-significant as well.
posthoc_year_df <- as.data.frame(posthoc_year)
posthoc_year_sig <- posthoc_year_df[posthoc_year_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_year_sig)

print("=== Plot 2: YearGroup comparisons within each Guild ===")
posthoc_diet_within <- pairs(emm_diet, by = "DietH")
# print(posthoc_diet_within)
posthoc_diet_within_df <- as.data.frame(posthoc_diet_within)
posthoc_diet_within_sig <- posthoc_diet_within_df[posthoc_diet_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_within_sig)

print("=== Plot 2: Guild comparisons within each YearGroup ===")
posthoc_diet_between <- pairs(emm_diet, by = "YearGroup")
# print(posthoc_diet_between)
posthoc_diet_between_df <- as.data.frame(posthoc_diet_between)
posthoc_diet_between_sig <- posthoc_diet_between_df[posthoc_diet_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_between_sig)

print("=== Plot 3: YearGroup comparisons within each Patch type ===")
posthoc_patch_within <- pairs(emm_patch, by = "Patch.type")
# print(posthoc_patch_within)
posthoc_patch_within_df <- as.data.frame(posthoc_patch_within)
posthoc_patch_within_sig <- posthoc_patch_within_df[posthoc_patch_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_within_sig)

print("=== Plot 3: Patch type comparisons within each YearGroup ===")
posthoc_patch_between <- pairs(emm_patch, by = "YearGroup")
# print(posthoc_patch_between)
posthoc_patch_between_df <- as.data.frame(posthoc_patch_between)
posthoc_patch_between_sig <- posthoc_patch_between_df[posthoc_patch_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_between_sig)

# Display plots
print(Bplot1)
print(Bplot2)
print(Bplot3)
```
## Old plots
```{r}
# Get interaction emmeans
emm_interaction <- emmeans(BmodelLoglink6, ~ YearGroup * DietH, type = "response")
emm_df_interaction <- as.data.frame(emm_interaction)

# Get compact letter display for the interaction
cld_interaction <- cld(emm_interaction, by = "DietH", Letters = letters, adjust = "sidak")
emm_df_interaction <- as.data.frame(cld_interaction)
emm_df_interaction$.group <- trimws(emm_df_interaction$.group)

# Plot 1: Grouped bars
plot1 <- ggplot(emm_df_interaction, aes(x = DietH, y = response, fill = YearGroup)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(
    aes(ymin = asymp.LCL, ymax = asymp.UCL),
    position = position_dodge(width = 0.8),
    width = 0.25
  ) +
  geom_text(
    aes(label = .group, y = asymp.UCL),
    position = position_dodge(width = 0.8),
    vjust = -0.5,
    size = 3
  ) +
  scale_fill_brewer(palette = "Set2", name = "Year Group") +
  labs(
    x = "Herbivore Guild",
    y = "Biomass (kg/ha)",
    title = "Predicted Biomass by Guild and Year Group"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_text(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain")
  )

# Plot 2: stacked bars
# Get interaction emmeans
emm_interaction <- emmeans(BmodelLoglink6, ~ YearGroup * DietH, type = "response")
emm_df_interaction <- as.data.frame(emm_interaction)

# Calculate the ACTUAL totals from the stacked bars
emm_totals_stacked <- emm_df_interaction %>%
  group_by(YearGroup) %>%
  summarise(
    total = sum(response),
    SE_total = sqrt(sum(SE^2)),
    .groups = "drop"
  ) %>%
  mutate(
    LCL = total - 1.96 * SE_total,
    UCL = total + 1.96 * SE_total
  )

# Now test differences between these totals using custom contrasts
# Get all combinations
emm_all <- emmeans(BmodelLoglink6, ~ YearGroup * DietH, type = "response")

# Create contrasts that sum guilds within each year, then compare years
contrast_list <- list(
  "2021-2022 vs 2023-2024" = c(1,1,1,1,1, -1,-1,-1,-1,-1, 0,0,0,0,0),
  "2021-2022 vs 2025" = c(1,1,1,1,1, 0,0,0,0,0, -1,-1,-1,-1,-1),
  "2023-2024 vs 2025" = c(0,0,0,0,0, 1,1,1,1,1, -1,-1,-1,-1,-1)
)

# Apply contrasts
total_comparisons <- contrast(emm_all, method = contrast_list, type = "response")
summary(total_comparisons, adjust = "sidak")

# Get p-values and assign letters manually based on results
pvals <- summary(total_comparisons, adjust = "sidak")
print(pvals)

# Assign letters based on the comparison results
# You'll need to look at the p-values and assign appropriately
emm_totals_stacked$`.group` <- c("a", "a", "b")  # Adjust based on your results

# Reorder DietH for stacking (largest at bottom)
emm_df_interaction <- emm_df_interaction %>%
  group_by(YearGroup) %>%
  mutate(DietH = fct_reorder(DietH, response, .desc = FALSE)) %>%
  ungroup()

# Create plot with correct totals
plot2 <- ggplot(emm_df_interaction, aes(x = YearGroup, y = response, fill = DietH)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_errorbar(
    data = emm_totals_stacked,
    aes(x = YearGroup, ymin = LCL, ymax = UCL),
    inherit.aes = FALSE,
    width = 0.25,
    linewidth = 0.8
  ) +
  geom_text(
    data = emm_totals_stacked,
    aes(x = YearGroup, y = UCL + 0.5, label = .group),
    inherit.aes = FALSE,
    size = 4
  ) +
  scale_fill_brewer(palette = "Set2", name = "Herbivore Guild") +
  labs(
    x = "Year Group",
    y = "Biomass (kg/ha)",
    title = "Predicted Biomass by Year Group (Stacked by Guild)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain")
  )


# Plotted per patch type
emm_df <- as.data.frame(emmeans(BmodelLoglink6, ~ DietH + Patch.type, type = "response"))
cld_total <- cld(emmeans(BmodelLoglink6, ~ Patch.type, type="response"), Letters=letters)

emm_totals <- emm_df %>%
  group_by(Patch.type) %>%
  summarise(
    total = sum(response),          # sum of predicted means
    SE_total = sqrt(sum(SE^2)),     # approximate SE of the sum
    .groups = "drop"
  ) %>%
  mutate(
    LCL = total - 1.96*SE_total,
    UCL = total + 1.96*SE_total
  )

emm_totals <- emm_totals %>%
  left_join(cld_total %>% dplyr::select(Patch.type, .group), by=c("Patch.type"))

emm_df <- emm_df %>%
  group_by(Patch.type) %>%
  mutate(DietH = fct_reorder(DietH, response, .desc = FALSE)) %>%
  ungroup()

plot3 <- ggplot(emm_df, aes(x = Patch.type, y = response, fill = DietH)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_errorbar(
    data = emm_totals,
    aes(x = Patch.type, ymin = LCL, ymax = UCL, group = Patch.type),
    inherit.aes = FALSE,
    width = 0.25,
    linewidth = 0.8
  ) +
  scale_fill_brewer(palette = "Set2", name = "Herbivore guild") +
  geom_text(
    data = emm_totals,
    aes(x = Patch.type, y = UCL + 0.10*max(UCL), label = .group),
    inherit.aes = FALSE
  ) +
  labs(
    x = "Patch type",
    y = "Biomass (kg/ha)",
    title = "Predicted biomass"
  ) +
  theme_minimal(base_size = 12) +  
  theme(
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain")
  )

print(plot1)
print(plot2)
print(plot3)

# Post-hoc
# Plot 1
posthoc_plot1 <- pairs(emm_interaction, by = "DietH", adjust = "sidak")
print("=== Plot 1: YearGroup comparisons within each Guild ===")
print(posthoc_plot1)
posthoc_plot1_df <- as.data.frame(posthoc_plot1)
posthoc_plot1_sig <- posthoc_plot1_df[posthoc_plot1_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_plot1_sig)
```
# Mean size
```{r}
# ---- DATA PREP ----
# Remove rows with no abundance (as those would lower mean sizes), or non-herbivorous fish and non-instantaneous observations
Meansize <- fish[fish$Abundance != 0 & fish$DietH != "Other" & fish$Coloured == 12,]

## First store metadata
survey_meta <- Meansize %>%
  dplyr::select(SurveyNo, Transect, Depth.MLLW, Reefdistance, ARdistance, Reef.dist_m, AR.dist_m, YearGroup, TransectDate, Patch.type, Treatment, Observer) %>%
  distinct()

Meansize$Size <- as.numeric(as.character(Meansize$Size))

# Go from size classes to mean size
Meansize <- Meansize %>%
  group_by(SurveyNo, DietH) %>%
  summarise(GuildMeansize = sum(Size * Abundance) / sum(Abundance),
            .groups = "drop")

# Bring back the lost metadata 
Meansize <- Meansize %>%
  left_join(survey_meta, by = "SurveyNo")
rm(survey_meta)
```
## Pre-model plots
```{r}
# Add the different guilds together per survey
Meansize_combined <- Meansize %>%
  group_by(SurveyNo, Depth.MLLW, Treatment, Reef.dist_m, AR.dist_m) %>%
  summarise (Meansize = sum(GuildMeansize))

# Correlation between reef depth and mean size
plot(Meansize_combined$Depth.MLLW, Meansize_combined$Meansize, xlab = "Depth", ylab = "Mean size (cm)", main = "Mean size vs Depth (covariate)")
abline(lm(Meansize ~ Depth.MLLW, data = Meansize_combined))
sum_lm <- summary (lm(Meansize ~ Depth.MLLW, data = Meansize_combined))
coef_lm <- sum_lm$coefficients
text(x = 7,
     y = 40,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 2 decimals
                     round(coef_lm[2,4],2),
                     "\ny = ",
                     #Round slope coefficient to 2 decimals
                     round(coef_lm[2,1],1),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from natural reef and mean fish size
Meansize_noREF <- Meansize_combined[Meansize_combined$Treatment != "Reference",] 
plot(Meansize_noREF$Reef.dist_m, Meansize_noREF$Meansize, xlab = "Reef distance", ylab = "Mean size (cm)", main = "Mean herbivore fish size vs distance from natural reef (covariate)")
abline(lm(Meansize ~ Reef.dist_m, data = Meansize_noREF))
sum_lm <- summary (lm(Meansize ~ Reef.dist_m, data = Meansize_noREF))
coef_lm <- sum_lm$coefficients
text(x = 23,
     y = 40,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 2 decimals
                     round(coef_lm[2,4],2),
                     "\ny = ",
                     #Round slope coefficient to 2 decimals
                     round(coef_lm[2,1],1),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from another AR and mean fish size
Meansize_ARonly <- Meansize_combined[Meansize_combined$Treatment == "AR",] 
plot(Meansize_ARonly$AR.dist_m, Meansize_ARonly$Meansize, xlab = "AR distance", ylab = "Mean size (cm)", main = "Mean herbivore fish size vs distance from another artifical reef (covariate)")
abline(lm(Meansize ~ AR.dist_m, data = Meansize_ARonly))
sum_lm <- summary (lm(Meansize ~ AR.dist_m, data = Meansize_ARonly))
coef_lm <- sum_lm$coefficients
text(x = 25,
     y = 40,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 2 decimals
                     round(coef_lm[2,4],2),
                     "\ny = ",
                     #Round slope coefficient to 2 decimals
                     round(coef_lm[2,1],1),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)
```
## Statistical models
```{r}
# Version 3: Log-link, testing if distances are significant
MSmodelLoglink1 <- glmmTMB(GuildMeansize ~ Depth.MLLW + Reef.dist_m + AR.dist_m + YearGroup * Patch.type + DietH + (1 | Transect) + (1| TransectDate:Observer), data = Meansize, family = tweedie(link="log"))

# Version 5: Log-link, excluding ARdist and using 0 proxies for reefdistance
MSmodelLoglink3 <- glmmTMB(GuildMeansize ~ Depth.MLLW + Reefdistance + YearGroup * Patch.type + DietH + (1 | Transect) + (1| TransectDate:Observer), data = Meansize, family = tweedie(link="log"))

# Version 6: Log-link, only reef distance and without depth due to insignificance
MSmodelLoglink5 <- glmmTMB(GuildMeansize ~ YearGroup * Patch.type * DietH  + Reefdistance + (1 | Transect) + (1| TransectDate:Observer), data = Meansize, family = tweedie(link="log"))
 
# Version 7: v6 but with just a two-way interaction: YearGroup * DietH
MSmodelLoglink6 <- glmmTMB(GuildMeansize ~ YearGroup * DietH + Patch.type + Reefdistance + (1 | Transect) + (1| TransectDate:Observer), data = Meansize, family = tweedie(link="log"))

# Look at model
Anova(MSmodelLoglink1) # Reefdistance is significant
Anova(MSmodelLoglink3) # Depth is insignificant
summary(MSmodelLoglink3)$coefficients$cond # Reefdistance has a small effect, but proportionally comparable some DietH / Year effects > include
Anova(MSmodelLoglink5) # Here, three way-interaction is significant
Anova(MSmodelLoglink6) # # YearGroup:DietH & YearGroup:Patch.type are significant. Also consider standalone YearGroup plot.
 
# Normality & homoscedasticity for DHARMa
MSsim_resLoglink5 <- simulateResiduals(fittedModel = MSmodelLoglink5, re.form = NULL)
MSsim_resLoglink6 <- simulateResiduals(fittedModel = MSmodelLoglink6, re.form = NULL)

# plot residuals
plot(MSsim_resLoglink5)
plot(MSsim_resLoglink6)
```

## Plots and post-hoc
```{r}
# Plot 1: YearGroup main effect
emm1 <- emmeans(MSmodelLoglink6, ~ YearGroup, type = "response")
cld1 <- cld(emm1, Letters = letters, adjust = "sidak")
emm1_df <- as.data.frame(cld1)
emm1_df$.group <- trimws(emm1_df$.group)

# Plot 1: Yeargroup main effect
MSplot1 <- ggplot(emm1_df, aes(x = YearGroup, y = response)) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), width = 0.2) +
  geom_point(size = 3) +
  geom_text(aes(label = .group, y = asymp.UCL), vjust = -0.5, size = 4) +
  labs(x = "Year Group", y = "Mean Size (cm)",
       title = "Mean herbivore fish size per survey over time",
      subtitle = "Main effect (YearGroup × Guild and YearGroup × Patch.type interactions significant)") +
  theme_bw()

# Plot 2: Yeargroup x DietH interaction
emm2 <- emmeans(MSmodelLoglink6, ~ YearGroup * DietH, type = "response")
cld_results <- cld(emm2, by = "DietH", Letters = letters)
emm2_df <- as.data.frame(cld_results)

# Trim whitespace from the compact letter display
emm2_df$.group <- trimws(emm2_df$.group)

# Create the plot
MSplot2 <- ggplot(emm4_df, aes(x = DietH, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Herbivore guild", y = "Mean Size (cm)",
       color = "Year Group",
       title = "Mean herbivore fish size per survey over time, by guild") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 3: Patch.type main effect
emm3 <- emmeans(MSmodelLoglink6, ~ Patch.type, type = "response")

cld3 <- cld(emm3, Letters = letters, adjust = "sidak")
emm3_df <- as.data.frame(cld3)
emm3_df$.group <- trimws(emm3_df$.group)

MSplot3 <- ggplot(emm3_df, aes(x = Patch.type, y = response)) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), width = 0.2) +
  geom_point(size = 3) +
  geom_text(aes(label = .group, y = asymp.UCL), vjust = -0.5, size = 4) +
  labs(x = "Patch Type", y = "Mean Size (cm)",
       title = "Mean herbivore fish size per survey by patch type") +
  theme_bw()

# Post-hoc
posthoc_year <- pairs(emm2)
print("=== Plot 1: YearGroup comparisons ===")
# print(posthoc_year) <if you want to see all non-significant as well.
posthoc_year_df <- as.data.frame(posthoc_year)
posthoc_year_sig <- posthoc_year_df[posthoc_year_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_year_sig)

posthoc_patch <- pairs(emm3)
print("=== Plot 2: Patch type comparisons ===")
print(posthoc_patch) # <if you want to see all non-significant as well.
posthoc_patch_df <- as.data.frame(posthoc_patch)
posthoc_patch_sig <- posthoc_patch_df[posthoc_patch_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_sig)

print("=== Plot 3: YearGroup comparisons within each Guild ===")
posthoc_diet_within <- pairs(emm4, by = "DietH")
# print(posthoc_diet_within)
posthoc_diet_within_df <- as.data.frame(posthoc_diet_within)
posthoc_diet_within_sig <- posthoc_diet_within_df[posthoc_diet_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_within_sig)

print("=== Plot 3: Guild comparisons within each YearGroup ===")
posthoc_diet_between <- pairs(emm4, by = "YearGroup")
# print(posthoc_diet_between)
posthoc_diet_between_df <- as.data.frame(posthoc_diet_between)
posthoc_diet_between_sig <- posthoc_diet_between_df[posthoc_diet_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_between_sig)

# Display plots
print(MSplot1)
print(MSplot2)
print(MSplot3)
```
## Old plots (three-way)
```{r}
# Plot 5: Three-way interaction (YearGroup x Patch.type x DietH)
emm5 <- emmeans(MSmodelLoglink5, ~ DietH * Patch.type * YearGroup, type = "response")
emm5_df <- as.data.frame(emm5)

# Get the actual combinations that exist in your data
actual_combinations <- unique(Meansize[, c("DietH", "Patch.type", "YearGroup")])

# Filter emmeans results to only include observed combinations
emm5_df <- merge(emm5_df, actual_combinations, by = c("DietH", "Patch.type", "YearGroup"))

# Calculate cld for each combination of Patch.type and DietH that actually exists
cld_list5 <- list()
for (patch in unique(emm5_df$Patch.type)) {
  for (diet in unique(emm5_df$DietH[emm5_df$Patch.type == patch])) {
    # Check if this combination has data
    if (nrow(emm5_df[emm5_df$Patch.type == patch & emm5_df$DietH == diet, ]) > 0) {
      emm_subset <- emmeans(MSmodelLoglink5, ~ YearGroup, 
                            at = list(Patch.type = patch, DietH = diet), 
                            type = "response")
      cld_subset <- cld(emm_subset, Letters = letters, adjust = "sidak")
      df_subset <- as.data.frame(cld_subset)
      df_subset$Patch.type <- patch
      df_subset$DietH <- diet
      df_subset$.group <- trimws(df_subset$.group)
      
      # Filter to only YearGroups that exist for this combination
      df_subset <- df_subset %>%
        semi_join(actual_combinations, by = c("DietH", "Patch.type", "YearGroup"))
      
      cld_list5[[paste(patch, diet, sep = "_")]] <- df_subset
    }
  }
}
emm5_df <- do.call(rbind, cld_list5)

plot5 <- ggplot(emm5_df, aes(x = DietH, y = response, 
                             color = factor(YearGroup), 
                             group = factor(YearGroup))) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), 
                width = 0.2, position = position_dodge(width = 0.5)) +
  geom_point(size = 3, position = position_dodge(width = 0.5)) +
  geom_text(aes(label = .group, y = asymp.UCL), 
            position = position_dodge(width = 0.5), 
            vjust = -0.5, size = 3, show.legend = FALSE) +
  facet_wrap(~ Patch.type, ncol = 1, scales = "free_y") +
  labs(x = "Diet", y = "Mean Size (cm)", 
       title = "Mean Size by Guild, Patch Type, and Year Group (Three-way Interaction)",
       color = "Year Group") +
  theme_bw() +
  theme(strip.text = element_text(face = "bold"))

Y_contrasts <- contrast(emm5,
                        "pairwise",
                        by = c("DietH","Patch.type"))
summary(Y_contrasts, infer = TRUE)
print(plot5)

```
# Abundance
```{r}
# ---- DATA PREP ----
# Remove rows with non-herbivorous fish, and non-instantaneous observations
Abundance <- fish[fish$DietH != "Other" & fish$Coloured == 12,]
Abundance <- droplevels(Abundance)

all_combos <- expand_grid(
  SurveyNo = unique(Abundance$SurveyNo),
  DietH = unique(Abundance$DietH))

# Go from abundance to species Abundance, and bring back 0 values for groups without observations
## First store metadata
survey_meta <- Abundance %>%
  dplyr::select(SurveyNo, Transect, Depth.MLLW, Reefdistance, ARdistance, Reef.dist_m, AR.dist_m, YearGroup, TransectDate, Patch.type, Treatment, Observer) %>%
  distinct()

## Count distinct herbivore species per herbivore guild per survey, and fill in 0 if there are none.
Abundance <- Abundance %>%
  group_by(SurveyNo, DietH) %>%
  summarise(GuildAbundance = sum(Abundance),
            .groups = "drop") %>%
  right_join(all_combos, by = c("SurveyNo", "DietH")) 

## Bring back metadata lost in group_by
Abundance <- Abundance %>%
  left_join(survey_meta, by = "SurveyNo")
rm(survey_meta, all_combos)
```
## Pre-model plots
```{r}
# Add the different guilds together per survey
Abundance_combined <- Abundance %>%
  group_by(SurveyNo, Depth.MLLW, Treatment, Reef.dist_m, AR.dist_m) %>%
  summarise (Abundance = sum(GuildAbundance))

# Correlation between reef depth and abundance
plot(Abundance_combined$Depth.MLLW, Abundance_combined$Abundance, xlab = "Depth", ylab = "Abundance",ylim = c(0,150), main = "Herbivore abundance vs Depth (covariate)")
abline(lm(Abundance ~ Depth.MLLW, data = Abundance_combined))
sum_lm <- summary (lm(Abundance ~ Depth.MLLW, data = Abundance_combined))
coef_lm <- sum_lm$coefficients
text(x = 7,
     y = 120,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from natural reef and abundance
Abundance_noREF <- Abundance_combined[Abundance_combined$Treatment != "Reference",] 
plot(Abundance_noREF$Reef.dist_m, Abundance_noREF$Abundance, xlab = "Reef distance", ylab = "Abundance", ylim = c(0,50),main = "Herbivore abundance vs distance from natural reef (covariate)")
abline(lm(Abundance ~ Reef.dist_m, data = Abundance_noREF))
sum_lm <- summary (lm(Abundance ~ Reef.dist_m, data = Abundance_noREF))
coef_lm <- sum_lm$coefficients
text(x = 23,
     y = 35,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

# Correlation between distance from another AR and species Abundance
Abundance_ARonly <- Abundance_combined[Abundance_combined$Treatment == "AR",] 
plot(Abundance_ARonly$AR.dist_m, Abundance_ARonly$Abundance, xlab = "AR distance", ylab = "Abundance", ylim = c(0,50), main = "Herbivore abundance vs distance from another artifical reef (covariate)")
abline(lm(Abundance ~ AR.dist_m, data = Abundance_ARonly))
sum_lm <- summary (lm(Abundance ~ AR.dist_m, data = Abundance_ARonly))
coef_lm <- sum_lm$coefficients
text(x = 23,
     y = 35,
     labels = paste0("R^2 = ",
                     #Round r.squared to 2 decimals
                     round(sum_lm$r.squared,2),
                     "\np-value = ",
                     #Round p.value of slope to 3 decimals
                     round(coef_lm[2,4],3),
                     "\ny = ",
                     #Round slope coefficient to 3 decimals
                     round(coef_lm[2,1],3),
                     "x + ",
                     #Round intercept coefficient to 2 decimals
                     round(coef_lm[1,1],2)),
     pos = 4)

rm(sum_lm)

# Conclusion: only Depth has a significant and considerable effect as a covariate, omit reef and AR distances here

```
## Statistical models
```{r}
# Version 1: Negative binomial to test Reef.dist and AR dist significance among AR
AmodelNB1 <- glmmTMB(GuildAbundance ~ Depth.MLLW + Reef.dist_m + AR.dist_m + YearGroup * Patch.type + DietH + (1 | Transect) + (1 | TransectDate:Observer), data = Abundance, family = nbinom2)

# Version 6: Distances omitted; they are insignificant and the effect size is too small to be interesting
AmodelNB6 <- glmmTMB(GuildAbundance ~ Depth.MLLW + YearGroup * Patch.type + DietH + (1 | Transect) + (1 | TransectDate:Observer), data = Abundance, family = nbinom2, dispformula = ~ Patch.type + DietH)

# Version 6: Distances omitted; they are insignificant and the effect size is too small to be interesting
AmodelNB7 <- glmmTMB(GuildAbundance ~ Depth.MLLW + YearGroup * Patch.type + YearGroup * DietH + (1 | Transect) + (1 | TransectDate:Observer), data = Abundance, family = nbinom2, dispformula = ~ Patch.type + DietH)

# Look at model
Anova(AmodelNB1) # ARdist is significant, REEFdist isn't
summary(AmodelNB1)$coefficients$cond # ARdist explains very little, thus is excluded
Anova(AmodelNB6) # YearGroup, Patch.type and DietH are all significant. Interaction is also significant.
Anova(AmodelNB7) # YearGroup:DietH & YearGroup:Patch.type are significant. Also consider standalone YearGroup plot.

# Normality, heteroscedasticity with DHARMa
Asim_resNB6 <- simulateResiduals(fittedModel = AmodelNB6, re.form = NULL)
Asim_resNB7 <- simulateResiduals(fittedModel = AmodelNB7, re.form = NULL)

plot(Asim_resNB6)
plot(Asim_resNB7)
```
## Plots and post-hoc
```{r}
# 1. YearGroup main effect
emm_year <- emmeans(AmodelNB7, ~ YearGroup, type = "response")
cld_year <- cld(emm_year, Letters = letters)
emm_year_df <- as.data.frame(cld_year)
emm_year_df$.group <- trimws(emm_year_df$.group)

# 2. YearGroup:DietH interaction
emm_diet <- emmeans(AmodelNB7, ~ YearGroup * DietH, type = "response")
cld_diet <- cld(emm_diet, by = "DietH", Letters = letters)
emm_diet_df <- as.data.frame(cld_diet)
emm_diet_df$.group <- trimws(emm_diet_df$.group)

# 3. YearGroup:Patch.type interaction
emm_patch <- emmeans(AmodelNB7, ~ YearGroup * Patch.type, type = "response")
cld_patch <- cld(emm_patch, by = "Patch.type", Letters = letters)
emm_patch_df <- as.data.frame(cld_patch)
emm_patch_df$.group <- trimws(emm_patch_df$.group)

# Plot 1: Yeargroup main effect
Aplot1 <- ggplot(emm_year_df, aes(x = YearGroup, y = response)) +
  geom_point(size = 3, color = "black") +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), 
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL), 
            vjust = -0.5, 
            size = 3) +
  labs(x = "Year Group", y = "Herbivore fish abundance",
       title = "Herbivore fish abundance per survey over time",
      subtitle = "Main effect (YearGroup × Guild and YearGroup × Patch.type interactions significant)") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Plot 2: Yeargroup x DietH interaction
Aplot2 <- ggplot(emm_diet_df, aes(x = DietH, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Herbivore guild", y = "Herbivore fish abundance", color = "Year Group",
       title = "Herbivore fish abundance per survey over time, by guild") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Plot 3: Yeargroup x Patch.type interaction
Aplot3 <- ggplot(emm_patch_df, aes(x = Patch.type, y = response, color = YearGroup, group = YearGroup)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL),
                position = position_dodge(width = 0.5),
                width = 0.2) +
  geom_text(aes(label = .group, y = asymp.UCL),
            position = position_dodge(width = 0.5),
            vjust = -0.5,
            size = 3,
            show.legend = FALSE) +
  labs(x = "Patch Type", y = "Herbivore fish abundance", color = "Year Group",
       title = "Herbivore fish abundance per survey over time, by patch type") +
  theme_minimal(base_size = 12) +
  theme_bw()

# Post-hoc
posthoc_year <- pairs(emm_year)
print("=== Plot 1: YearGroup comparisons ===")
# print(posthoc_year) <if you want to see all non-significant as well.
posthoc_year_df <- as.data.frame(posthoc_year)
posthoc_year_sig <- posthoc_year_df[posthoc_year_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_year_sig)

print("=== Plot 2: YearGroup comparisons within each Guild ===")
posthoc_diet_within <- pairs(emm_diet, by = "DietH")
# print(posthoc_diet_within)
posthoc_diet_within_df <- as.data.frame(posthoc_diet_within)
posthoc_diet_within_sig <- posthoc_diet_within_df[posthoc_diet_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_within_sig)

print("=== Plot 2: Guild comparisons within each YearGroup ===")
posthoc_diet_between <- pairs(emm_diet, by = "YearGroup")
# print(posthoc_diet_between)
posthoc_diet_between_df <- as.data.frame(posthoc_diet_between)
posthoc_diet_between_sig <- posthoc_diet_between_df[posthoc_diet_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_diet_between_sig)

print("=== Plot 3: YearGroup comparisons within each Patch type ===")
posthoc_patch_within <- pairs(emm_patch, by = "Patch.type")
# print(posthoc_patch_within)
posthoc_patch_within_df <- as.data.frame(posthoc_patch_within)
posthoc_patch_within_sig <- posthoc_patch_within_df[posthoc_patch_within_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_within_sig)

print("=== Plot 3: Patch type comparisons within each YearGroup ===")
posthoc_patch_between <- pairs(emm_patch, by = "YearGroup")
# print(posthoc_patch_between)
posthoc_patch_between_df <- as.data.frame(posthoc_patch_between)
posthoc_patch_between_sig <- posthoc_patch_between_df[posthoc_patch_between_df$p.value < 0.05, ]
print("Significant comparisons:")
print(posthoc_patch_between_sig)

# Display plots
print(Aplot1)
print(Aplot2)
print(Aplot3)
```
## Old plots (Stacked)
```{r}
# Plot 4: YearGroup with stacked bars for DietH
emm_df4 <- as.data.frame(emmeans(AmodelNB6, ~ YearGroup + DietH, type = "response"))

# Get marginal means for YearGroup for the cld letters
emm4_year <- emmeans(AmodelNB6, ~ YearGroup, type = "response")
cld4_year <- cld(emm4_year, Letters = letters, adjust = "sidak") %>%
  as.data.frame()

# Calculate totals by summing across DietH
emm4_totals <- emm_df4 %>%
  group_by(YearGroup) %>%
  summarise(
    total = sum(response),
    SE_total = sqrt(sum(SE^2)),  # Approximate SE by combining individual SEs
    .groups = "drop"
  ) %>%
  mutate(
    LCL = total - 1.96 * SE_total,  # 95% CI
    UCL = total + 1.96 * SE_total
  )

# Add cld letters
emm4_totals <- emm4_totals %>%
  left_join(cld4_year[, c("YearGroup", ".group")], by = "YearGroup")

# Reorder DietH by size (largest at bottom)
emm_df4 <- emm_df4 %>%
  group_by(YearGroup) %>%
  mutate(DietH = fct_reorder(DietH, response, .desc = FALSE)) %>%
  ungroup()

plot4 <- ggplot(emm_df4, aes(x = YearGroup, y = response, fill = DietH)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_errorbar(
    data = emm4_totals,
    aes(x = YearGroup, y = total, ymin = LCL, ymax = UCL),
    inherit.aes = FALSE,
    width = 0.25,
    linewidth = 0.8
  ) +
  geom_text(
    data = emm4_totals,
    aes(x = YearGroup, y = UCL + 0.05*max(UCL), label = trimws(.group)),
    inherit.aes = FALSE
  ) +
  scale_fill_brewer(palette = "Set2", name = "Herbivore guild") +
  labs(
    x = "Yeargroup",
    y = "Mean Abundance",
    title = "Mean herbivore fish abundance by yeargroup and guild"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain")
  )

# Plot 5: YearGroup on x-axis, faceted by Patch.type
emm5df <- as.data.frame(emmeans(AmodelNB6, ~ YearGroup * Patch.type + DietH, type = "response"))

# Get marginal means for cld
emm5_year <- emmeans(AmodelNB6, ~ YearGroup | Patch.type, type = "response")
cld5_year <- cld(emm5_year, Letters = letters, adjust = "sidak") %>%
  as.data.frame()

# Calculate totals by summing across DietH
emm5_totals <- emm5_df %>%
  group_by(YearGroup, Patch.type) %>%
  summarise(
    total = sum(response),
    SE_total = sqrt(sum(SE^2)),  # Approximate SE by combining individual SEs
    .groups = "drop"
  ) %>%
  mutate(
    LCL = total - 1.96 * SE_total,  # 95% CI
    UCL = total + 1.96 * SE_total
  )

# Add cld letters
emm5_totals <- emm5_totals %>%
  left_join(cld5_year[, c("YearGroup", "Patch.type", ".group")], by = c("YearGroup", "Patch.type"))

# Reorder DietH (largest at bottom)
emm5_df <- emm5_df %>%
  group_by(YearGroup, Patch.type) %>%
  mutate(DietH = fct_reorder(DietH, response, .desc = FALSE)) %>%
  ungroup()

plot5 <- ggplot(emm5_df, aes(x = YearGroup, y = response, fill = DietH)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_errorbar(
    data = emm5_totals,
    aes(x = YearGroup, y = total, ymin = LCL, ymax = UCL),
    inherit.aes = FALSE,
    width = 0.25,
    linewidth = 0.8
  ) +
  geom_text(
    data = emm5_totals,
    aes(x = YearGroup, y = UCL + 0.05*max(UCL), label = trimws(.group)),
    inherit.aes = FALSE,
    size = 3
  ) +
  facet_wrap(~ Patch.type) +
  scale_fill_brewer(palette = "Set2", name = "Herbivore guild") +
  labs(
    x = "Yeargroup",
    y = "Mean Abundance",
    title = "Mean herbivore fish abundance by yeargroup and patch type"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "grey90"),
    legend.title = element_text(face = "plain"),
    strip.text = element_text(face = "plain")
  )

# Display plots
print(plot4)
print(plot5)
```
# Ordination plots (With YearGroups combined)
```{r}
# ---- DATA PREP, similar to Biomass ----
# Remove rows with non-herbivorous fish, and non-instantaneous observations
BiomassNMDS <- fish[fish$DietH != "Other" & fish$Coloured == 12,]

# Remove second/third observers on same survey to prevent pseudoreplication
## Make separate surveyNo list with observer and YearGroup
Surveys <- unique(fish[, c("SurveyNo", "Observer", "Transect", "YearGroup")])

## For surveys done with two people, only one is chosen (preferably the student, as they have done all)
Surveys <- Surveys %>%
  group_by(YearGroup, Transect) %>% 
  # choose the correct row per YearGroup + Transect
  filter(
    case_when(
      ## In 2021-2022, Jelle Rienstra did everything twice, so can use only him
      YearGroup == "2021–2022" ~ Observer == "Jelle Rienstra",
      ## In 2023-2024, if Anniek Leinenga did it > choose Anniek. If not > choose Ewout Knoester
      YearGroup == "2023–2024" ~ 
        if ("Anniek Leinenga" %in% Observer) {
          Observer == "Anniek Leinenga"
        } else {
          Observer == "Ewout Knoester"
        },
      ## In 2025, Jorn de Gelder did all of the surveys at least once, so can use only him
      YearGroup == "2025" ~ Observer == "Jorn de Gelder",
      TRUE ~ FALSE
    )
  ) %>%
  ungroup()

## Use only the selected surveys
BiomassNMDS <- BiomassNMDS %>%
  semi_join(Surveys, by = "SurveyNo")

# Getting rid of sizeclasses
## First store metadata
survey_meta <- BiomassNMDS %>%
  dplyr::select(SurveyNo, Transect, Depth.MLLW, Reef.dist_m, AR.dist_m, YearGroup, TransectDate, Patch.type, Treatment, Observer) %>%
  distinct()
metadata <- as.numeric(length(survey_meta))

## Sum biomass per species per survey
BiomassNMDS <- BiomassNMDS %>%
  group_by(SurveyNo, Species) %>%
  summarise(Biomass = sum(Biomass_kgha),
            .groups = "drop")

# Go to wide for Bray-Curtis dissimilarity
BiomassNMDS <- BiomassNMDS %>% pivot_wider( names_from = Species, values_from = Biomass)
BiomassNMDS[is.na(BiomassNMDS)] <- 0

# Remove surveys with no herbivorous fish & fish that have never been observed
empty_rows <- rowSums(BiomassNMDS[,-1]) == 0
empty_cols <- colSums(BiomassNMDS[,-1]) == 0
BiomassNMDS <- BiomassNMDS[ !empty_rows, ]
BiomassNMDS <- BiomassNMDS[ , c(TRUE, !empty_cols) ]

# Bring back metadata lost in group_by above
BiomassNMDS <- BiomassNMDS %>% left_join(survey_meta, by = "SurveyNo")
fishdata <- as.numeric(length(BiomassNMDS))
BiomassNMDS_data <- BiomassNMDS[2:(fishdata-metadata+1)]
rm(survey_meta)

BiomassNMDS_exclOUT <- BiomassNMDS[-c(147), ]
BiomassNMDS_data_exclOUT <- BiomassNMDS_data[-c(147), ]

# PERMANOVA
# Bray-Curtis distance
bray_dist <- vegdist(BiomassNMDS_data, method = "bray")

## Adonis
adonis_results <- adonis2(BiomassNMDS_data ~ Patch.type,
                          data = BiomassNMDS,
                          method = "bray",
                          permutations = 999)
print(adonis_results)

## Check homogeneity of dispersions
disp <- betadisper(bray_dist, BiomassNMDS$Patch.type)
disp_anova <- anova(disp)
print(disp_anova)

# PERMANOVA without Outliers (sensitivity analysis)
# Bray-Curtis distance without Outliers (sensitivity analysis)
bray_dist <- vegdist(BiomassNMDS_data_exclOUT, method = "bray")

## Adonis
adonis_results <- adonis2(BiomassNMDS_data_exclOUT ~ Patch.type,
                          data = BiomassNMDS_exclOUT,
                          method = "bray",
                          permutations = 999)
print(adonis_results)

## Check homogeneity of dispersions without Outliers (sensitivity analysis)
disp <- betadisper(bray_dist, BiomassNMDS_exclOUT$Patch.type)
disp_anova <- anova(disp)
print(disp_anova)

## Post-hoc manual pairwise PERMANOVA
groups <- levels(BiomassNMDS$Patch.type)
results <- data.frame(
  Group1 = character(),
  Group2 = character(),
  F = numeric(),
  R2 = numeric(),
  p.value = numeric(),
  stringsAsFactors = FALSE
)

## Pairwise manually, as pairwiseAdonis doesn't work..
for (i in 1:(length(groups)-1)) {
  for (j in (i+1):length(groups)) {
    sel <- BiomassNMDS$Patch.type %in% c(groups[i], groups[j])
    dist_sub <- vegdist(BiomassNMDS_data[sel, ], method = "bray")
    grp_sub <- BiomassNMDS$Patch.type[sel]
    
    res <- adonis2(dist_sub ~ grp_sub, permutations = 999)
    
    results <- rbind(
      results,
      data.frame(
        Group1 = groups[i],
        Group2 = groups[j],
        F = res$F[1],
        R2 = res$R2[1],
        p.value = res$`Pr(>F)`[1]
      )
    )
  }
}

results <- results %>% mutate(p.adj = p.adjust(p.value, method = "BH"))
results

# Make NMDS plot
nmds = metaMDS(BiomassNMDS_data_exclOUT, distance = "bray")
site.scores = as.data.frame(scores(nmds)$sites)
site.scores$Patch.type = BiomassNMDS_exclOUT$Patch.type
site.scores$SampleID <- rownames(site.scores)
species.scores <- as.data.frame(scores(nmds, display = "species"))
                        
## Get four samples with highest and lowest nMDS values:
coords <- as.data.frame(nmds$points)
outliers1High <- coords[order(coords$MDS1, decreasing = TRUE)[1:5], ]
outliers1Low <- coords[order(coords$MDS1, decreasing = FALSE)[1:5], ]
outliers2High <- coords[order(coords$MDS2, decreasing = TRUE)[1:5], ]
outliers2Low <- coords[order(coords$MDS2, decreasing = FALSE)[1:5], ]

## Make vectors for the guilds, but exclude the three outliers
### Make species:guild frame, to look up which species belongs to which guild
guild_lookup <- fish %>%
  dplyr::select(Species, DietH) %>%
  dplyr::filter(DietH != "Other") %>%
  dplyr::distinct() %>%
  dplyr::rename(Guild = DietH)

## Make guild-level biomass matrix
guild_biomass <- BiomassNMDS_data_exclOUT %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Species") %>%
  left_join(guild_lookup, by = "Species") %>%
  group_by(Guild) %>%
  summarise(across(-Species, sum)) %>%
  column_to_rownames("Guild") %>%
  t()  # transpose so rows = sites, cols = guilds

## Use envfit for the vectors
guild_envfit <- envfit(nmds, guild_biomass, permutations = 999)
print(guild_envfit)
vectors <- as.data.frame(scores(guild_envfit, display = "vectors"))
vectors$Guild <- rownames(vectors)
vectors_segments <- vectors %>%
  mutate(x = 0, y = 0, xend = NMDS1, yend = NMDS2)

pvals <- guild_envfit$vectors$pvals
vectors_segments$pval <- pvals
vectors_segments_sig <- subset(vectors_segments, pval < 0.05)

```

## Plots with outlier
``` {r}
ggplot(site.scores,aes(x = NMDS1, y = NMDS2)) +
  geom_point(size = 3, aes(colour = Patch.type)) +
  geom_text(
    data = subset(site.scores, SampleID %in% c("192","191","175","170","144", "163", "88")),
    aes(label = SampleID),
    hjust = -0.2, fontface = "bold", size = 4
  ) +
  geom_segment(
    data = vectors_segments_sig,
    aes(x = x, y = y, xend = xend, yend = yend),
    arrow = arrow(length = unit(0.25, "cm")),
    colour = "red",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = vectors_segments_sig,
    aes(x = xend, y = yend, label = Guild),
    colour = "red",
    hjust = 0.5,
    vjust = -0.5,
    inherit.aes = FALSE
  ) +
  theme(axis.text = element_text(size = 12, colour = "black"),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14),
    panel.background = element_blank(),
    panel.border = element_rect(fill = NA, colour = "black", linewidth = 1.2)) +
  labs(x = "NMDS1", y = "NMDS2", colour = "Patch.type") +
  scale_colour_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733")) +
  scale_fill_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733"))
```
## Plots without outlier, but with inset
```{r}
# Start from full data and null out the 3 outliers only for ellipse grouping
data_ell <- site.scores
data_ell$Patch.type[data_ell$SampleID %in% c("192","191","175","170","144", "163", "88")] <- NA  # mask them, don't drop

# Now run ordiellipse with a full-length grouping vector
ell <- ordiellipse(
  nmds,
  groups = data_ell$Patch.type,
  kind = "se",
  conf = 0.99,
  draw = "none"
)

vectorfactor <- 2

ellipse_df <- do.call(rbind, lapply(names(ell), function(g) {
  df <- as.data.frame(
    vegan:::veganCovEllipse(ell[[g]]$cov, ell[[g]]$center, sqrt(qchisq(0.99, df = 2)))
  )
  colnames(df) <- c("NMDS1", "NMDS2")
  df$Patch.type <- g
  df
}))

main_plot <- ggplot(subset(site.scores, !(SampleID %in% c("192","191","175","170","144", "163", "88"))), 
        aes(x = NMDS1, y = NMDS2)) +
  geom_point(size = 3, aes(colour = Patch.type)) +
  geom_polygon(data = ellipse_df, aes(x = NMDS1, y = NMDS2, fill = Patch.type),
               alpha = 0.40, colour = NA) +
    geom_segment(
    data = vectors_segments_sig,
    aes(x = x, y = y, xend = xend * vectorfactor, yend = yend * vectorfactor),
    arrow = arrow(length = unit(0.25, "cm")),
    colour = "red",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = vectors_segments_sig,
    aes(x = xend* vectorfactor * 1.1, y = yend * vectorfactor * 1.1, label = Guild),
    colour = "red",
    hjust = 0.5,
    vjust = -0.5,
    inherit.aes = FALSE
  ) +
  theme(axis.text = element_text(size = 12, colour = "black"),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 14),
        panel.background = element_blank(),
        panel.border = element_rect(fill = NA, colour = "black", linewidth = 1.2)) +
  labs(x = "NMDS1", y = "NMDS2", colour = "Patch.type", fill = "Patch.type") +
  scale_colour_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733")) +
  scale_fill_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733"))

# Create a column for coloring
site.scores$InsetColor <- ifelse(site.scores$SampleID %in% c("192","191","175","170","144", "163", "88"),
                                 as.character(site.scores$Patch.type), "Other")

# Define colors for Patch.type
patch_colors <- c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0")
names(patch_colors) <- c("BRU", "CAGE", "CAKE", "COMP", "Control", "Reference") 
inset_colors <- c("Other" = "lightgrey", patch_colors)

# Inset plot
inset_plot <- ggplot(site.scores, aes(x = NMDS1, y = NMDS2)) +
  geom_point(size = 2, aes(colour = InsetColor)) +
  scale_colour_manual(values = inset_colors) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title = element_blank(),
    panel.grid = element_blank(),
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.8)
  )

# Combine with main plot
final_plot <- ggdraw() +
  draw_plot(main_plot) +
  draw_plot(inset_plot, x = 0.15, y = 0.65, width = 0.20, height = 0.30)

final_plot
```
# Ordination plots (with YearGroups splitted)
```{r}
# ---- DATA PREP, similar to Biomass ----
# Remove rows with non-herbivorous fish, and non-instantaneous observations
BiomassNMDS <- fish[fish$DietH != "Other" & fish$Coloured == 12,]

# Remove second/third observers on same survey to prevent pseudoreplication
## Make separate surveyNo list with observer and YearGroup
Surveys <- unique(fish[, c("SurveyNo", "Observer", "Transect", "YearGroup")])

## For surveys done with two people, only one is chosen (preferably the student, as they have done all)
Surveys <- Surveys %>%
  group_by(YearGroup, Transect) %>% 
  # choose the correct row per YearGroup + Transect
  filter(
    case_when(
      ## In 2021-2022, Jelle Rienstra did everything twice, so can use only him
      YearGroup == "2021–2022" ~ Observer == "Jelle Rienstra",
      ## In 2023-2024, if Anniek Leinenga did it > choose Anniek. If not > choose Ewout Knoester
      YearGroup == "2023–2024" ~ 
        if ("Anniek Leinenga" %in% Observer) {
          Observer == "Anniek Leinenga"
        } else {
          Observer == "Ewout Knoester"
        },
      ## In 2025, Jorn de Gelder did all of the surveys at least once, so can use only him
      YearGroup == "2025" ~ Observer == "Jorn de Gelder",
      TRUE ~ FALSE
    )
  ) %>%
  ungroup()

## Use only the selected surveys
BiomassNMDS <- BiomassNMDS %>%
  semi_join(Surveys, by = "SurveyNo")

# Go from Biomass to species Biomass, and bring back 0 values for groups without observations
## First store metadata
survey_meta <- BiomassNMDS %>%
  dplyr::select(SurveyNo, Transect, Depth.MLLW, Reef.dist_m, AR.dist_m, TransectDate, Patch.type, Treatment, Observer) %>%
  distinct()
metadata <- as.numeric(length(survey_meta))

## Sum biomass per herbivore guild per survey, and fill in 0 if there are none.
BiomassNMDS <- BiomassNMDS %>%
  group_by(SurveyNo, Species, YearGroup) %>%
  summarise(Biomass = sum(Biomass_kgha),
            .groups = "drop")

# Go to wide for Bray-Curtis dissimilarity
BiomassNMDS <- BiomassNMDS %>% pivot_wider( names_from = Species, values_from = Biomass)
BiomassNMDS[is.na(BiomassNMDS)] <- 0

# Remove surveys with no herbivorous fish & fish that have never been observed
empty_rows <- rowSums(BiomassNMDS[,-c(1,2)]) == 0
empty_cols <- colSums(BiomassNMDS[,-c(1,2)]) == 0
BiomassNMDS <- BiomassNMDS[ !empty_rows, ]
BiomassNMDS <- BiomassNMDS[ , c(TRUE, TRUE, !empty_cols) ]

# Bring back metadata lost in group_by above
BiomassNMDS <- BiomassNMDS %>% left_join(survey_meta, by = "SurveyNo")
fishdata <- as.numeric(length(BiomassNMDS))
BiomassNMDS_data <- BiomassNMDS[3:(fishdata-metadata+1)]
rm(survey_meta)

BiomassNMDS_exclOUT <- BiomassNMDS[-c(147), ]
BiomassNMDS_data_exclOUT <- BiomassNMDS_data[-c(147), ]

# PERMANOVA
# Bray-Curtis distance
bray_dist <- vegdist(BiomassNMDS_data, method = "bray")

## Adonis: interaction tested as well (as Patch.type:YearGroup), but that isn't significant for community
adonis_results <- adonis2(BiomassNMDS_data ~ Patch.type * YearGroup,
                          data = BiomassNMDS,
                          method = "bray",
                          permutations = 999,
                          by = "terms")
print(adonis_results)

# PERMANOVA without outliers
# Bray-Curtis distance
bray_dist <- vegdist(BiomassNMDS_data_exclOUT, method = "bray")

## Check homogeneity of dispersions
disp <- betadisper(bray_dist, BiomassNMDS_exclOUT$Patch.type)
disp_anova <- anova(disp)
print(disp_anova)

## Adonis: interaction tested as well (as Patch.type:YearGroup), but that isn't significant for community
adonis_results <- adonis2(BiomassNMDS_data_exclOUT ~ Patch.type * YearGroup,
                          data = BiomassNMDS_exclOUT,
                          method = "bray",
                          permutations = 999,
                          by = "terms")
print(adonis_results)

## Check homogeneity of dispersions
disp <- betadisper(bray_dist, BiomassNMDS_exclOUT$Patch.type)
disp_anova <- anova(disp)
print(disp_anova)

## Post-hoc manual pairwise PERMANOVA (for Patch.type within each YearGroup)
## Compare different Patch.types within the same YearGroup

year_groups <- levels(BiomassNMDS$YearGroup)

for (year in year_groups) {
  cat("\n=== Patch.type comparisons within YearGroup:", year, "===\n")
  
  # Subset data for this YearGroup
  sel_year <- BiomassNMDS$YearGroup == year
  BiomassNMDS_year <- BiomassNMDS[sel_year, ]
  BiomassNMDS_data_year <- BiomassNMDS_data[sel_year, ]
  
  # Get patch types for this year
  patch_types <- levels(droplevels(BiomassNMDS_year$Patch.type))
  
  results_year <- data.frame(
    YearGroup = character(),
    Group1 = character(),
    Group2 = character(),
    F = numeric(),
    R2 = numeric(),
    p.value = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (i in 1:(length(patch_types)-1)) {
    for (j in (i+1):length(patch_types)) {
      sel <- BiomassNMDS_year$Patch.type %in% c(patch_types[i], patch_types[j])
      dist_sub <- vegdist(BiomassNMDS_data_year[sel, ], method = "bray")
      grp_sub <- BiomassNMDS_year$Patch.type[sel]
      
      res <- adonis2(dist_sub ~ grp_sub, permutations = 999)
      
      results_year <- rbind(
        results_year,
        data.frame(
          YearGroup = year,
          Group1 = patch_types[i],
          Group2 = patch_types[j],
          F = res$F[1],
          R2 = res$R2[1],
          p.value = res$`Pr(>F)`[1]
        )
      )
    }
  }
  
  results_year <- results_year %>%
    mutate(p.adj = p.adjust(p.value, method = "BH"))
  
  print(results_year)
}


## Post-hoc manual pairwise PERMANOVA (for YearGroup within each Patch.type)
## Compare the same Patch.type across different YearGroups

patch_types <- levels(BiomassNMDS$Patch.type)
year_groups <- levels(BiomassNMDS$YearGroup)

results_all_patches <- data.frame(
  Patch.type = character(),
  Group1 = character(),
  Group2 = character(),
  F = numeric(),
  R2 = numeric(),
  p.value = numeric(),
  stringsAsFactors = FALSE
)

for (patch in patch_types) {
  # Subset data for this Patch.type
  sel_patch <- BiomassNMDS$Patch.type == patch
  BiomassNMDS_patch <- BiomassNMDS[sel_patch, ]
  BiomassNMDS_data_patch <- BiomassNMDS_data[sel_patch, ]
  
  # Get year groups for this patch type
  years <- levels(droplevels(BiomassNMDS_patch$YearGroup))
  
  for (i in 1:(length(years)-1)) {
    for (j in (i+1):length(years)) {
      sel <- BiomassNMDS_patch$YearGroup %in% c(years[i], years[j])
      dist_sub <- vegdist(BiomassNMDS_data_patch[sel, ], method = "bray")
      grp_sub <- BiomassNMDS_patch$YearGroup[sel]
      
      res <- adonis2(dist_sub ~ grp_sub, permutations = 999)
      
      results_all_patches <- rbind(
        results_all_patches,
        data.frame(
          Patch.type = patch,
          Group1 = years[i],
          Group2 = years[j],
          F = res$F[1],
          R2 = res$R2[1],
          p.value = res$`Pr(>F)`[1]
        )
      )
    }
  }
}

results_all_patches <- results_all_patches %>%
  mutate(p.adj = p.adjust(p.value, method = "BH"))

results_all_patches

# Make NMDS plot
nmds = metaMDS(BiomassNMDS_data_exclOUT, trymax = 100, distance = "bray")
site.scores = as.data.frame(scores(nmds)$sites)
site.scores$Patch.type = BiomassNMDS_exclOUT$Patch.type
site.scores$YearGroup = BiomassNMDS_exclOUT$YearGroup
site.scores$SampleID <- rownames(site.scores)
species.scores <- as.data.frame(scores(nmds, display = "species"))

# Get two samples with highest NMDS1 values:
coords <- as.data.frame(nmds$points)
outliers1High <- coords[order(coords$MDS1, decreasing = TRUE)[1:5], ]
outliers1Low <- coords[order(coords$MDS1, decreasing = FALSE)[1:5], ]
outliers2High <- coords[order(coords$MDS2, decreasing = TRUE)[1:5], ]
outliers2Low <- coords[order(coords$MDS2, decreasing = FALSE)[1:5], ]

## Make vectors for the guilds, but exclude the three outliers
### Make species:guild frame, to look up which species belongs to which guild
guild_lookup <- fish %>%
  dplyr::select(Species, DietH) %>%
  dplyr::filter(DietH != "Other") %>%
  dplyr::distinct() %>%
  dplyr::rename(Guild = DietH)

## Get YearGroup information for each survey
biomass_with_yeargroup <- BiomassNMDS_exclOUT %>%
  dplyr::select(SurveyNo, YearGroup) %>%
  bind_cols(BiomassNMDS_data_exclOUT)

## Create guild biomass for each YearGroup separately
guild_biomass_by_year <- biomass_with_yeargroup %>%
  pivot_longer(cols = -c(SurveyNo, YearGroup), 
               names_to = "Species", 
               values_to = "Biomass") %>%
  left_join(guild_lookup, by = "Species") %>%
  group_by(YearGroup, SurveyNo, Guild) %>%
  summarise(Biomass = sum(Biomass), .groups = "drop") %>%
  pivot_wider(names_from = Guild, 
              values_from = Biomass, 
              values_fill = 0)

## Calculate envfit for each YearGroup
vectors_all <- list()

## outliers to exclude for vector calculation.
exclude_samples <- c("191", "192", "175", "170", "163", "144", "88")
guild_biomass_by_year$SampleID <- rownames(guild_biomass_by_year)
BiomassNMDS_exclOUT$SampleID <- rownames(BiomassNMDS_exclOUT)

for(year_grp in unique(guild_biomass_by_year$YearGroup)) {
  # Filter data for this YearGroup AND exclude specific samples
  guild_matrix <- guild_biomass_by_year %>%
    filter(YearGroup == year_grp,
           !SampleID %in% exclude_samples) %>%  # Add exclusion filter here
    dplyr::select(-YearGroup, -SampleID) %>%  # Remove SampleID column too
    column_to_rownames("SurveyNo")
  
  # Get NMDS scores and add SurveyNo from the original data
  # Also exclude the same samples here
  nmds_scores <- scores(nmds, display = "sites") %>%
    as.data.frame() %>%
    rownames_to_column("temp_index") %>%
    bind_cols(BiomassNMDS_exclOUT %>% dplyr::select(SurveyNo, YearGroup, SampleID)) %>%  # Include SampleID
    filter(!SampleID %in% exclude_samples) %>%  # Exclude samples
    dplyr::select(-temp_index, -SampleID) %>%  # Remove temporary columns
    column_to_rownames("SurveyNo") %>%
    dplyr::select(NMDS1, NMDS2)
  
  # Ensure both have the same rows in the same order
  common_surveys <- intersect(rownames(nmds_scores), rownames(guild_matrix))
  nmds_scores <- nmds_scores[common_surveys, ]
  guild_matrix <- guild_matrix[common_surveys, ]
  
  # Calculate envfit for this subset
  guild_envfit_subset <- envfit(nmds_scores, guild_matrix, permutations = 999)
  
  print(paste("YearGroup:", year_grp))
  print(guild_envfit_subset)
  
  # Extract vectors
  vectors <- as.data.frame(scores(guild_envfit_subset, display = "vectors"))
  vectors$Guild <- rownames(vectors)
  vectors$YearGroup <- year_grp
  vectors$pval <- guild_envfit_subset$vectors$pvals
  vectors_all[[year_grp]] <- vectors
}

## Combine all vectors into one dataframe
vectors_segments <- bind_rows(vectors_all) %>%
  mutate(x = 0, y = 0, xend = NMDS1, yend = NMDS2)
vectors_segments_sig <- subset(vectors_segments, pval < 0.05)
```

## Plots with outlier
``` {r}
ggplot(site.scores,aes(x = NMDS1, y = NMDS2)) +
  geom_point(size = 3, aes(colour = Patch.type)) +
  geom_text(
    data = subset(site.scores, SampleID %in% c("191","192","175", "170","163", "144", "88")),
    aes(label = SampleID),
    hjust = -0.2, fontface = "bold", size = 4
  ) +
  geom_segment(
    data = vectors_segments_sig,
    aes(x = x, y = y, xend = xend, yend = yend),
    arrow = arrow(length = unit(0.25, "cm")),
    colour = "red",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = vectors_segments_sig,
    aes(x = xend, y = yend, label = Guild),
    colour = "red",
    hjust = 0.5,
    vjust = -0.5,
    inherit.aes = FALSE
  ) +
  facet_wrap(~ YearGroup) + 
  theme(axis.text = element_text(size = 12, colour = "black"),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14),
    panel.background = element_blank(),
    panel.border = element_rect(fill = NA, colour = "black", linewidth = 1.2)) +
  labs(x = "NMDS1", y = "NMDS2", colour = "Patch.type") +
  scale_colour_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733")) +
  scale_fill_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733"))
```
## Plot with inset
```{r}
# Start from full data and null out outliers for ellipse grouping
data_ell <- site.scores
data_ell$Patch.type[data_ell$SampleID %in% c("191","192","175", "170","163", "144", "88")] <- NA

# Calculate ellipses separately for each YearGroup
ellipse_df <- do.call(rbind, lapply(unique(data_ell$YearGroup), function(year) {
  # Create a grouping vector for this year (NA for other years)
  groups_year <- data_ell$Patch.type
  groups_year[data_ell$YearGroup != year] <- NA
  
  # Run ordiellipse using the full nmds but with year-specific grouping
  ell <- ordiellipse(
    nmds,
    groups = groups_year,
    kind = "se",
    conf = 0.99,
    draw = "none"
  )
  
  # Extract ellipse coordinates
  year_ellipse <- do.call(rbind, lapply(names(ell), function(g) {
    df <- as.data.frame(
      vegan:::veganCovEllipse(ell[[g]]$cov, ell[[g]]$center, sqrt(qchisq(0.99, df = 2)))
    )
    colnames(df) <- c("NMDS1", "NMDS2")
    df$Patch.type <- g
    df$YearGroup <- year  # Add the year group identifier
    df
  }))
  
  year_ellipse
}))

# Define outliers per YearGroup (adjust based on your data)
outliers_by_year <- list(
  "2021-2022" = c("88"),
  "2023-2024" = character(0),  # no outliers in this year
  "2025" = c("192","191","175","170","144", "163")
)

# Get unique year groups from your data
year_groups <- sort(unique(site.scores$YearGroup))

# Calculate shared axis limits based on NON-OUTLIER data only
all_outliers <- unique(unlist(outliers_by_year))
data_no_outliers <- subset(site.scores, !(SampleID %in% all_outliers))
nmds1_range <- range(data_no_outliers$NMDS1)
nmds2_range <- range(data_no_outliers$NMDS2)
# Add some padding
nmds1_limits <- nmds1_range + c(-0.1, 0.1) * diff(nmds1_range)
nmds2_limits <- nmds2_range + c(-0.1, 0.1) * diff(nmds2_range)

# Function to create main plot for one YearGroup
create_facet_main <- function(year_group, outliers, show_y_label = TRUE, show_y_text = TRUE, show_x_label = FALSE) {
  # Subset data
  data_main <- subset(site.scores, 
                      YearGroup == year_group & 
                      !(SampleID %in% outliers))
  ellipse_year <- subset(ellipse_df, YearGroup == year_group)
  vectors_year <- subset(vectors_segments_sig, YearGroup == year_group)
  
  vectorfactor <- 1
  
  p <- ggplot(data_main, aes(x = NMDS1, y = NMDS2)) +
    geom_point(size = 3, aes(colour = Patch.type)) +
    geom_polygon(data = ellipse_year, 
                 aes(x = NMDS1, y = NMDS2, fill = Patch.type),
                 alpha = 0.40, colour = NA) +
    geom_segment(
      data = vectors_year,
      aes(x = x, y = y, xend = xend * vectorfactor, yend = yend * vectorfactor),
      arrow = arrow(length = unit(0.25, "cm")),
      colour = "red",
      inherit.aes = FALSE
    ) +
    geom_text(
      data = vectors_year,
      aes(x = xend * vectorfactor * 1.3, y = yend * vectorfactor * 1.3, label = Guild),
      colour = "red",
      hjust = 0.5,
      vjust = -0.5,
      inherit.aes = FALSE,
      size = 3.5
    ) +
    coord_cartesian(xlim = nmds1_limits, ylim = nmds2_limits) +
    ggtitle(year_group) +
    theme(
      axis.text.x = element_text(size = 12, colour = "black"),
      axis.text.y = if(show_y_text) element_text(size = 12, colour = "black") else element_blank(),
      axis.ticks.y = if(show_y_text) element_line() else element_blank(),  # Hide y-axis ticks
      axis.title.x = if(show_x_label) element_text(size = 14) else element_text(size = 14, colour = "white"),  # Invisible but preserves space
      axis.title.y = if(show_y_label) element_text(size = 14) else element_blank(),
      legend.position = "none",
      panel.background = element_blank(),
      panel.border = element_rect(fill = NA, colour = "black", linewidth = 1.2),
      plot.title = element_text(hjust = 0.5, size = 12, face = "bold")
    ) +
    labs(x = if(show_x_label) "NMDS1" else "NMDS1",  # Always set label
         y = if(show_y_label) "NMDS2" else "",
         colour = "Patch.type", 
         fill = "Patch.type") +
    scale_colour_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733")) +
    scale_fill_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733"))
  
  return(p)
}

# Function to create inset plot for one YearGroup
create_facet_inset <- function(year_group, outliers) {
  if (length(outliers) == 0) return(NULL)
  
  data_inset <- subset(site.scores, YearGroup == year_group)
  data_inset$InsetColor <- ifelse(data_inset$SampleID %in% outliers,
                                   as.character(data_inset$Patch.type), 
                                   "Other")
  
  patch_colors <- c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0", "#FF5733")
  names(patch_colors) <- c("BRU", "CAGE", "CAKE", "COMP", "Control", "Reference", "Other")
  inset_colors <- c("Other" = "lightgrey", patch_colors)
  
  ggplot(data_inset, aes(x = NMDS1, y = NMDS2)) +
    geom_point(size = 1.5, aes(colour = InsetColor)) +
    scale_colour_manual(values = inset_colors) +
    theme_minimal() +
    theme(
      legend.position = "none",
      axis.title = element_blank(),  # No axis titles
      axis.text = element_text(size = 8, colour = "black"),  # Show axis values
      panel.grid = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.8)
    )
}

# Create combined plots for each YearGroup (with insets overlaid)
plots_list <- lapply(seq_along(year_groups), function(i) {
  year <- year_groups[i]
  outliers <- outliers_by_year[[year]]
  if (is.null(outliers)) outliers <- character(0)
  
  # Only show y-label and y-text on first plot, x-label only on middle plot (but preserve space on all)
  main <- create_facet_main(year, outliers, 
                            show_y_label = (i == 1),
                            show_y_text = (i == 1),
                            show_x_label = (i == 2))  # Only middle shows visible label
  inset <- create_facet_inset(year, outliers)
  
  if (!is.null(inset)) {
    # Overlay inset on top-left, shifted right to avoid y-axis
    ggdraw() +
      draw_plot(main) +
      draw_plot(inset, x = 0.12, y = 0.70, width = 0.25, height = 0.25)
  } else {
    # No inset, just main plot
    main
  }
})

# Create a dummy plot to extract legend with original styling using ellipses
legend_plot <- ggplot(site.scores, aes(x = NMDS1, y = NMDS2, colour = Patch.type, fill = Patch.type)) +
  geom_point(size = 3, aes(colour = Patch.type)) +
  geom_polygon(data = ellipse_df, aes(x = NMDS1, y = NMDS2, fill = Patch.type),
               alpha = 0.40, colour = NA) +
  scale_colour_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0")) +
  scale_fill_manual(values = c("#B0E54D", "#6FDCD9", "#F0C862", "#EC86BF","#D04E08", "#0673B0")) +
  theme(legend.text = element_text(size = 12),
        legend.title = element_text(size = 14),
        legend.key = element_rect(fill = "white", colour = NA))

# Extract legend as a grob
legend <- get_legend(legend_plot)

# Combine: 3 plots + legend using plot_grid from cowplot
final_plot <- plot_grid(
  plots_list[[1]], 
  plots_list[[2]], 
  plots_list[[3]], 
  legend,
  nrow = 1,
  rel_widths = c(1.08, 1, 1, 0.3)
)

final_plot
```

# Figure compilation
```{r compilation}

# # Richness, Abundance and Biomass combined in one panel
# RAB <- plot_grid(Divplot, Bioplot,Abuplot, nrow = 3, align = "v", rel_heights = c(1,1,1.2),
#                  labels = c("A", "B", "C"), label_size = 18)
# ggsave("Fish_Richness and Abundance and Biomass.tiff", width = 18, height = 24, units = "cm", dpi=1200, compression = "lzw", RAB)


```
